{"pages":[{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"},{"title":"About","text":"我是葉子","link":"/about/index.html"}],"posts":[{"title":"連葉子都秒懂的 Fast Forward","text":"fast-forward 出現時機在進行 merge 的時候，git 預設會以 fast-forward 的模式進行 情境說明：當開設 branch feature/add-page 後要回到 master 合併 branch目前狀況： 若使用預設的 merge 採用 fast-forward 進行： 會將 branch 的 commit 紀錄合併到 master 上 指令：git merge feature/add-page 不使用 fast-forward ，以 no fast-forward 進行： 會保留原始 branch 上的 commit 紀錄，並在 master 上增加一個merge branch 'feature/add-page' into master 指令：git merge feature/add-page --no-ff–no-ff 不要快速合併 no fast-forward 的好處 可以完整保留每一個分支的 commit 紀錄 no fast-forward 的壞處 若是 commit 紀錄只有一個，合併多次就會出現很多小叉路","link":"/2019/06/20/Git/fast-forward/"},{"title":"Vue CLI 3 快速建立篇","text":"Vue CLI 3 在建立專案上已經可以利用 GUI 的方式來建立，不需要輸入一堆指令！官網說明：https://cli.vuejs.org/zh/guide/creating-a-project.html 使用 GUI 介面建立專案先介紹如何使用 GUI 介面建立專案 在終端機輸入：1vue ui 輸入後就會開啟一個瀏覽器介面，如下圖： 建立新專案點選創建，並選擇要創建專案的資料夾位置，選好後按下在此建立項目即可 Step1: 詳情 (Details)預設是填寫專案名稱以及選擇模組管理要使用 npm 或是 yarn，選擇預設則會兩者都有安裝，最後也有提供創建 git 的選擇可以依照自己的開發習慣填入，就可以到下一步了～ Step2: 預設 (Presets)預設有提供三個選項: 默認 (Default preset) 手動 (Manual) 遠程預設 (Remote preset) 默認 (Default preset)默認是一套已經定義好的插件與配置，選擇後就會使用這個配置直接創建專案預設也可以自己設定，可以透過選擇手動 (Manual) 來選取自己在開發上常用的配置並設為預設 手動 (Manual)只有選擇手動才會進入頁面中的功能與配置頁面 選擇手動 (Manual) 配置可以選擇下一步，就會進入功能頁面（Step3） 可以選擇自己常用的插件，像是 Bebal、ESLint、CSS 預處理器等等 選擇好以後按下一步就會進入到最後的配置頁面（Step4）這邊可以選擇像是 ESLint 要使用何種規範等等的細節設定 遠程預設 (Remote preset)遠程預設是可以使用 github、gitlab 等等已經設定好的遠端設定檔來直接創建專案主要是載入 preset.json 這個檔案 如果是使用 github 公開儲存庫中的檔案只要輸入 username / repo 就可以了如果是使用 gitlab, bitbucket 可以在前面加上前綴詞 這邊載入的是這位作者寫好的：https://github.com/xiabaiyang/vue-preset 以上，不管使用何種方式都可以建立起一個新專案～ RUN 一下新建立的專案在終端機輸入：npm1npm run serve yarn1yarn serve 就可以建立起來了！畫面： 還想再安裝插件如果在預設的時候沒有選擇好插件或是配置，可以再透過指令在建置好的專案中加入 例如： ESLint在終端機輸入：1vue add @vue/eslint 加入 Router1vue add router","link":"/2018/12/28/Vue/Vue-CLI3-create/"},{"title":"使用 CSS 和 JS 呈現打字機效果","text":"這篇主要是說明如何運用幾個 CSS 和 JS 觀念來做出打字機的效果。 話不多說，先看 DEMO：DEMO 主要觀念 CSS keyframes animation 設定 JS setInterval() contains() if, else 程式碼說明HTML先從 HTML 結構來說:第一層 div 是為了設定鼠標的活動空間是和字體寬度相等，因此會設定為 display: inline-block第二層 div (#typewrite-animated) 則是打字機動畫效果的設定層再往內是打字機文字顯示的地方 (#typewrite-text)12345&lt;div class=&quot;d-inline-block&quot;&gt; &lt;div id=&quot;typewrite-animated&quot;&gt; &lt;span id=&quot;typewrite-text&quot; class=&quot;d-inline-block&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; CSS接著來看 CSS 樣式設定的部分如同上面 HTML 區塊提到的，為了讓寬度適應內容，會設定 display: inline-block。因此第一個樣式就是：123.d-inline-block { display: inline-block;} 接著進入重點的鼠標以及打字機效果的說明。我們把主要的動畫效果寫到 .typewriter span，而 typewriter 就是要加到 #typewrite-animated 並動態被切換的 class123456789.typewriter span { font-size: 72px; overflow: hidden; border-right: .3rem solid $dark; white-space: nowrap; animation: typing 0.6s steps(3, end), blink-caret .5s step-end infinite;} font-size: 設定字體大小 overflow: hidden: 隱藏文字顯示 border-right: 設定鼠標寬度 white-space: nowrap: 讓文字不換行 animation: 設定動畫 animation這邊要特別說明動畫的部分，有加上兩個值。第一個是 typing 0.6s steps(3, end)typing 0.6s steps(3, end) 中的第一個參數 typing 是說明動畫名稱，會對應到 keyframe 的設定1234@keyframes typing { from { width: 0 } to { width: 100% }} 也就是外部的寬度由 0 到 100%，而 0.6s 則是指這個動畫過程的時間，第三個參數則是指 animation-timing-function。animation-timing-function 這個屬性是用來控制動畫播放的速度與加速度，常見的值有 linear、ease-in、ease-out 等等，而這邊使用的 steps 也是其中的值，這邊就來介紹一下 steps 吧！ steps()steps 中可以帶兩個參數，第一個是數字，代表的是要將動畫切為幾格，第二個 position 是指動畫從斷點頭或是斷點尾開始。 從 W3C 的圖來看是這樣：圖片來自 W3C 實際從範例可以更清楚地理解，請打開以下範例：https://codepen.io/carlos411/pen/wRKRej 範例來自 Carlos-Studio 設計好網站 到這邊就可以了解 steps() 的使用，可以讓文字變成一個一個出現。而範例呈現的文字數有 3 個，所以 steps 設定是 3。以此類推，若有五個字就 steps 就設定為 5。 而第二個值 blink-caret .5s step-end infinite; 用法也如同上面提到的，blink-caret 是動畫名稱，對應的 keyframes 是設定鼠標的閃爍效果，由透明到黑色。1234@keyframes blink-caret { from, to { border-color: transparent } 50% { border-color: $dark }} 同樣使用 step-end 讓鼠標有閃動的感覺，最後參數 infinite 讓動畫可以持續的重複播放 JS最後說明一下 JS 的部分：主要是透過 setInterval() 來做每一次的切換變化 123456789101112131415161718192021222324252627282930// 透過 arr 陣列儲存要變化的文字內容const arr = ['寫程式', '做設計', '找工作'];// 用 count 計算次數，後面會用來計算目前要顯示的文字內容是哪一個let count = 0;// 用 setInterval 做每一次的切換變化setInterval( function() { count += 1; // 設定動畫名稱並取得元素 const typewriteAni = document.getElementById('typewrite-animated'); const typewriteText = document.getElementById('typewrite-text'); // 判斷 #typewrite-animated 的 class 中是否含有 'typewriter' 這個 class if (typewriteAni.classList.contains('typewriter')) { // 有的話就移除 typewriteAni.classList.remove('typewriter'); } else { // 沒有的話就加上 typewriteAni.classList.add('typewriter'); // 監聽元素 animationend 事件，動畫執行完 800 毫秒後清掉文字與 'typewriter' 這個 class typewriteAni.addEventListener('animationend', function() { setTimeout(function() { typewriteText.textContent = ''; typewriteAni.classList.remove('typewriter'); }, 800) }) } // 用 count%3 來計算目前要取得的 arr 位置是第幾個（arr 中有 3 筆就用 %3，五筆就 %5） typewriteText.textContent = arr[count%3];}, 2500); JS 補給站：animationend eventanimationend 事件，就如同 click 事件一樣，可以透過 addEventListener 來對元素做監聽。animationend 是指在 CSS 動畫執行完後再執行後面函式設定的內容 contains()contains 方法可以用在 DOMTokenList，而元素的 classList（ele.classList）回傳的正是一個 DOMTokenList 物件，所以這邊要確認是否有某個 class 就需要使用 contains。 有一個與 contains 很像的方法，也就是 Array 的 includes，要注意這邊若要使用 includes，要先將 DOMTokenList 轉為 Array。例如：[...typewriteAni.classList].includes('typewriter') 參考資料animation-timing-function 的 steps 函式Carlos-Studio 設計好網站","link":"/2019/11/13/CSS/css-typewriter/"},{"title":"HTML img 下方有不明空隙？！","text":"之前在回覆問題時，不少人都會發現這個有點奇怪的現象 - 圖片下方有一個莫名的間距這一篇就來說明一下原理以及解決方法吧！ 如下面 codepen 範例中，圖片下方會有一個空隙： See the Pen img-blank by TzuHui (@TzuHui) on CodePen. 原因說明因為圖片預設是 inline 元素，而 inline 元素的 vertical-align 設定預設是和父元素的 baseline 對齊的，而 baseline 本身又和父元素底邊有一定的間距。這個間距是來自於英文文字中像是 j, y 這些超過基準線的字符。 圖片來自 overstackflow 回覆 解法了解原因之後也就可以明白，要去除掉下方的空隙可以使用以下三種方法： 解法一：123img { vertical-align: top/bottom/text-top/text-bottom;} 解法一是可以將 vertical-align 的設定修改為 top/bottom/text-top/text-bottom 改變與父元素的對齊基準。 解法二：123img { display: block;} 解法二的用意是將 img 改為區塊元素，讓圖片不會因為行內（inline）元素的特性而受到影響。 解法三123.box { font-size: 0px;} .box 是指 img 的父元素，解法三的方式是讓文字大小為 0px，進而讓因為文字而有的間距不見。","link":"/2020/01/08/HTML/html-img-blank/"},{"title":"Vue CLI 3 環境變數設置","text":"使用 Vue 開發時若有使用到 firebse 資料庫，會需要將資料庫金鑰加入到專案中，但在 commit 時不建議將金鑰也一併 commit 到公開的儲存庫上，這時就會建議使用環境變數 新增一個 .env.local新增的 .env.local 會在所有環境中被載入，但會被 git 忽略在 .env.local 中加入環境變數，例如：123456FIREBASE_APIKEY=KeyFIREBASE_AUTODOMAIN=DomainFIREBASE_DATABASEURL=DatabaseUrlFIREBASE_PROJECTID=ProjectIdFIREBASE_STORAGEBUCKET=StorageBucketFIREBASE_MESSAGINGSENDERID=MessagingsId 左邊為環境變數的變數名稱，通常以全部都大寫字母來命名右邊是金鑰的內容，在 firebase 中可以取得相關的資料 在 JS 中取得環境變數設置在 JS 中要使用環境變數，只要在變數前加上 process.env 就可以了～例如：1process.env.FIREBASE_APIKEY 部署要注意的地方將金鑰改為環境變數之後，因為只有在本地端才能使用，所以要注意部署網站時要將環境變數設定到機器上以部署到 heroku 為例： 進入 heroku 專案畫面，點選 Settings，在 Settings 頁面有設定環境變數的地方 - Config Vars 點選 Reveal Config Vars 將變數加上，如下圖： 官網的環境變數說明：https://cli.vuejs.org/zh/guide/mode-and-env.html","link":"/2019/01/08/Vue/Vue-CLI3-env/"},{"title":"在 Vue Cli 中加入自定義 Bootstrap 樣式","text":"常常忘記該怎麼加入自定義的 Bootstrap 樣式，所以直接記下來不囉唆！基礎的引入很簡單，按照步驟一定搞定～ 安裝 1npm install bootstrap --save 在 src 下的 assets 建立 helpers 資料夾並將 node_moduled 中的 bootstrap _variables.scss 複製過去 在 src 下的 assets 建立 all.scss 檔案用來管理所有 scss 在 all.scss 引入順序 123@import \"~bootstrap/scss/functions\";@import 'helpers/variables';@import \"~bootstrap/scss/bootstrap\"; 在 App.vue 中引入 all.scss 123&lt;style lang=\"scss\"&gt; @import \"./assets/all.scss\"&lt;/style&gt; 如果要再加入其他自定義的 scss 可以在 src 下的 assets 建立 components 資料夾ㄅㄨ並加入自定義的元件 scss 樣式，接著再 all.scss 引入就完成了！","link":"/2019/06/20/Bootstrap/vue-cli-use-bootstrap/"},{"title":"Vue CLI 3 安裝篇","text":"Vue CLI 3 安裝非常簡單和官網上說明的可以說是一模一樣 XD官網說明：https://cli.vuejs.org/zh/guide/ Stpe1: 卸載舊版 Vue CLI(本來就沒有安裝 Vue CLI 的話就可以跳過此步驟)Vue CLI 的模組名稱已經由 vue-cli 改成了 @vue/cli所以如果已經全局安裝 vue-cli (1.x 或 2.x)，要先卸載 在終端機輸入： npm1npm uninstall vue-cli -g yarn1yarn global remove vue-cli Stpe2: 安裝 CLI 3 指令卸載後就可以安裝 CLI 3 在終端機輸入： npm1npm install -g @vue/cli yarn1yarn global add @vue/cli Stpe3: 確認 Vue CLI 版本1vue --version 如果顯示 3.x.x 就代表安裝成功 安裝完成後就可以來建立專案囉！ 裝了 CLI 3 還是可以用 CLI 2 的模板Vue CLI 3 和以往的版本都使用了相同的 vue 命令所以如果要使用舊版的 vue init，只要全局安裝一個工具 在終端機輸入： 1npm install -g @vue/cli-init 安裝完後 ·vue init，vue init 的執行結果會和 vue-cli@2.x 相同1vue init webpack my-project","link":"/2018/12/28/Vue/Vue-CLI3-install/"},{"title":"Vue Cli 部署到 Github Pages","text":"圖文說明使用 Vue Cli 開發後，如何將 build 出的靜態檔推到 gh-pages 分支，並使用 GitHub Pages 開啟。 流程：開發完成後，要先設定部署的路徑，再 build 檔案，並部署到 gh-pages 分支。 步驟 1: 設定部署的路徑這邊設定的 /repoName/ 是指 github 儲存庫的名稱。 Vue Cli 2:在 config 資料夾中的 index.js 做設定 1234build: { // ... assetsPublicPath: &apos;/repoName/&apos;,} 要注意是修改 build 的地方 Vue Cli 3:在 vue.config.js 中設定 publicPath (如果沒有 vue.config.js 需要自行新增一個) 12345module.exports = { publicPath: process.env.NODE_ENV === &apos;production&apos; ? &apos;/repoName/&apos; : &apos;/&apos;} 步驟 2：build 並部署到 gh-pages 分支使用 shell這個方法是我覺得最方便也是最常使用的方法，在 Vue 官方文件中，也是提供這個方法 新增一個 deploy.sh 到資料夾中新增的存放位置可以參考下圖： 將以下內容加入到 sh 中，並要注意更換 git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git 為自己的儲存庫路徑 12345678910111213141516171819#!/usr/bin/env sh# 当发生错误时中止脚本set -e# 构建npm run build# cd 到构建输出的目录下 cd distgit initgit add -Agit commit -m &apos;deploy&apos;# 部署到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master:gh-pagescd - git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git取得可參考下圖： 在終端機執行 sh deploy.sh 這樣就會成功的部署上去囉！接下來只要到 gitube 儲存庫上 Settings 中設定 Github Pages 為 gh-pages 要顯示的即可","link":"/2020/03/02/Vue/Vue-CLI3-to-github-pages/"},{"title":"隨著六角飄到三週年同學會的葉子漂流記","text":"這次同學會是我進六角以後第一次在實體見到學員，因為擔任助教的關係，有些學員的名字我都印象深刻，但都沒有見過本人，因此透過活動與大家見到面，有一種很特別的感覺！ 在同學會有一小段時間是讓學員們可以找大家聊天，當時有一些學員和我聊聊，我統整並分類了一下問題，並分享自己的想法。 心理上的問題我很不好意思在社團上與大家交流怎麼辦？/我想找和我學習狀況相似的夥伴，但我很不擅於主動發文互動怎麼辦？當時我和她說，社團上的大家都很友善！沒關係，妳可以先試試看。說不定你的發文剛好也會吸引到和你相同的背景或是學習狀況的人。我也是比較不擅於在主動在線上交流的人，但最近也正嘗試在寫文作紀錄，妳也可以先嘗試看看，會有這樣的害怕是很正常的，妳不是一個人。 🍃葉子心裡話：當時被問這個問題時，我心裡有「咚」的一聲。因為這個問題好像同樣的發生在自己身上。我也是比較少在線上分享自身經驗的人，有蠻大一部分的原因是出自於我是一個比較沒有自信的人。曾經我也想過透過寫文的方式來分享，但通常都是寫了發不出去，就這樣成為永遠的草稿（莫名的糾結啊啊啊當時我有將這個情況和洧杰老師談談，其中有一個讓我印象深刻的話：「妳要先學會接納自己是什麼樣的人」如同前面提到，事實上我就是比較沒有自信的人，所以在寫文的時候會很糾結說這樣寫會不會讓人覺得怎麼樣怎麼樣之類的但學著面對這樣的自己，我告訴自己：「沒自信也沒關係的，就先試試看吧！總之我得先做，才有可能會發生我在憂慮的問題嘛！」於是慢慢開始試著去找一些小主題來寫，雖然不是博大精深，但總是踏出了那一小步！我知道這個努力讓我比前一刻的自己更勇敢了！ 學一學覺得有點怠惰了怎麼辦 / 全職轉職的壓力好大學習並不是只有在於時間長短，適當的休息與舒壓也是必須的！當壓力過大時很容易影響到專注度，而專注度也同樣會影響到學習的效率，或是因此產生情緒，讓自己對事情鑽牛角尖。因此我自己在壓力比較大的時候，會先給自己一些耍廢的時間。找一件可以讓自己放鬆的事情，例如：到書店看書 在書店時會多看一些最近煩惱的事情，並嘗試在書中找到一些方法來做嘗試。像是有一陣子我會有莫名的疲倦感，就買了『與焦慮和解』以及『五秒法則』等等的書，從書中了解的原來自己的狀況可能是因為焦慮，也從五秒法則這本書，試著了解自己每天的狀態。 🍃葉子心裡話：因此噴了不少在買書上呢… 有興趣或許可以來和我借（？） 看很多人分享都覺得他們好強，反觀自己會覺得好弱呀…通常你會覺得很強的對象，他們身上都有一個你想達到的目標。別急著反觀自己的弱項，可以試著思考看看，這個對象是哪一點讓你覺得厲害，或是是你想學習的。例如：某一項技術學得很深入、對底層觀念很熟悉、文章寫得很有條理、很會與他人互動等等，了解哪一部份是你認為很厲害的點之後，可以將這些事情記錄下來，並依照接下來想達成的或是有興趣的安排學習的先後順序。寫下來後一方面是可以減少焦慮，讓自己可以對下來要如何安排目標更有方向，另一方面也可以深入思考到這是否是你想繼續往前的方向。 剛入行前端一年多，接下來該怎麼走？其實六角學院是我第一份工作，而我進入到六角工作大約是一年多的時間，所以被問到這個問題時，其實我還蠻惶恐的，哈哈比起大多數經驗豐富的學長姐，我應該還算是個職場小菜鳥。因此只能就自己的想法給予一些建議，首推老師的文章：https://ithelp.ithome.com.tw/articles/10194994https://ithelp.ithome.com.tw/articles/10218115透過文章中可以了解到接下來自己可以去努力的方向。成為前端後我也會有很迷茫的時候，覺得技術不斷更新，而且看到徵才條件都要會好多，我是不是學更多種才可以呢？這個問題我自己的結論會傾向是先專精工作上所需要用到的技能，當工作也比較能穩定上手時，也比較會有多餘的時間或是精力去精進其他的技能。 學習上的問題跟著JS 課程寫作業都覺得很 ok，但自己要從零開始就沒辦法這個問題其實一直以來都有蠻多學員有這個疑問，因為跟著一步一步做，所以比較容易就忽略自己對這部分的掌握度，建議可以在完成後回頭看一次，有些學員也會在每一行加上註解，確定自己對於這個執行過程是了解的。接下來可以嘗試開發其他的專案，來鍛鍊自己對語法與邏輯的熟悉程度。初步要從零開始寫的時候通常都會毫無頭緒，此時會建議將想要做出來的功能寫下來，並切成一小個一小個功能，先專注在達成第一步，再繼續往後舉例來說：我想做出購物流程，那可能可以簡單分為以下幾步， 先有一個按鈕是可以『加入購物車』 加入購物車以後可以到購物車頁面，確認購買的商品 在此頁面可以刪除商品 填寫資料表單 送出 -&gt; 確認購買成功 因此第一步就先專注在新增點擊的監聽事件到按鈕上，並觸發將商品的資料加到購物車（可能是一個陣列）中，完成這一步後，再往第二部分來做 切成個別功能來做的好處在於，專心於某一個部分，且在完成一項後就會先得到成就感，再往下投入也會更有動力。但同樣也會有壞處，也就是這個方法容易想的不夠全面，因此比較建議是在初學熟悉的時候使用哩（請小心服用 如何準備作品集特別推薦大家可以到 THE F2E 前端修煉精神時光屋逛逛第一屆：https://www.facebook.com/groups/173311386703334/learning_content/第二屆：https://challenge.thef2e.com/兩屆的題目都不相同，而第二屆更是有許多 UI 設計師提供設計稿，可以到裡面找尋自己喜歡的版型來練習。這邊也有許多厲害的工程師的作品，有些甚至有提供原始碼可以參考，可說是人人有功練的好去處呢！ 這邊也提倡一下，在六角學習的好處就是，若你做完了課程最終作業，可以申請求職輔導的服務，也可以提供自己的履歷與作品集請老師幫忙看，現在也有人才牆的服務（這不是業配，是真心 R! 關於助教的問題一題問題都花多少時間回覆？回覆問題的時間會依照熟練程度以及問題難度而定。先以熟練度來說，我剛到六角的時候，大概是一個 HTML 課程就需要花 2-3 小時的時間回覆。後來比較熟練回覆以後，慢慢增加課程，到後面大概是 2-3 小時 4 個課程（網頁排版）至於 JS 或是 Vue 就會更無法拿捏時間，有時候可能一題就一小時了！這就是問題難度的部分～ 而遇到真的無法解的問題，就會詢問老師。目前因為有遠端助教的幫忙，就轉為檢視的角色，自己回覆的時間就少了許多。 每天打開問答區會不會覺得很厭世？看到問題量很多或是瀏覽過一次問題，發現似乎有比較難解的，會有一點小壓力但是解完問題，或是整理出一個詳細的回覆提供給學員參考時，就會有一種爽感 XD最重要的是，當看到學員點擊回覆有幫助或是回覆說謝謝，心裡都會偷偷竊喜一下。 🍃葉子心裡話：同學會當天有兩個可愛的女孩說要和我告白，感謝我的回覆當時真的是非常開心，了解到自己的回覆是真的有幫助到別人的時候，就會覺得很有成就感呢！ 問題都是你看過的嗎？其實每週都一定會有我不熟悉的問題，但也是因為接受到各種問題，讓我也從回覆中釐清很多觀念，這也是當助教的好處當看到不了解的問題，就是先 google 再說！透過 stackoverflow, mdn 以及官方文件或是網路上很多大神的文章都可以找到滿滿的資料，將資料搜集並整理後再回覆給學員，同時也是讓自己吸收與釐清的好方法哦 我想當遠端助教若你對遠端助教有興趣，非常歡迎加入！我們都會不定期徵選，條件與職務內容可以參考文章https://www.hexschool.com/2019/08/01/2019-08-01-remote-jobs-second/ 擔任遠端助教的好處是可以透過大量的問題，釐清自己的觀念，從中也可以獲得成就感因為是有給職，所以對於全職轉職的學員，也可以多一份收入減低生活壓力 最後，我想感謝…非常感謝那天來和我說謝謝以及來找我聊聊的學員們你們也給我很大的鼓勵！有你們才促成了這篇文章希望這篇文章也同樣可以給予你們力量，讓你們可以找到自己想邁進的方向！也很感謝和我說官網做得好的學長姊，被你們肯定讓我很感動啊啊啊～我也會繼續努力，與大家一起成長的！也謝謝六角，讓我的人生又添上一筆美好的回憶記錄 :D","link":"/2019/10/01/Mine/hexschool-third-party/"},{"title":"漂流在 MOPCON 2019 的葉子成長記","text":"今年是我第一次擔任 MOPCON 志工，我的職務是資訊組的前端。在資訊組主要是做官網以及 CMS 的前端開發，此次還多加了一個電子看板，一開始很怕自己會雷到別人，對於職場菜鳥的我來說，完全遠端的工作也是一大挑戰，但透過組長的帶領，也順利的完成這次分派到的工作，從中學習到技能、溝通等等，接下來一一紀錄下這將近半年美好的漂流回憶～ 資訊組的工作法主要是採用 scrum 這個敏捷開發的方法來進行組的運作，以兩個禮拜為期是一個 sprint，每個 sprint 每個人都會有自己的 sprint Goal，並固定每週五的時候回報進度，回報的內容為： 上週做了 下週要做 遇到的問題 有需要處理的事項也會開 issue 並 assign 處理對象，除非是需要多方討論的事項才會約線上會議討論。一開始其實會有『這樣我會不會不知道自己要幹嘛 QQ』的感覺，但實際上 run 起來是非常順暢的，每週需要做的目標都會很清楚的列出，且超棒的組長 hash 也會私下關心狀況，『會不會壓力太大』、『目前分配的工作還 ok 嗎』並說有任何狀況都可以反應給他，在開發期間他也會 code review 的非常仔細，因為他的帶領讓我安心很多，如同他在交流議程分享時提到的『不讓組員感覺是一個人，我們是一個 team』 雖然大家都有各自的工作，但也都很願意為活動分享經驗、互相交流與技術指導，若是有組員在某段時間比較忙碌也都會幫忙 cover，也因為這樣共同努力的氣氛，讓我也同樣會很希望自己能幫上更多。由於是完全遠端的關係，除了在 git 上有技能點的提升，在事情的溝通上也比較了解到『如何用文字說明的方式，讓人了解你的問題』。 技能點的提升這次我主要負責到的項目有 CMS 的前端、MOPCON 官網部分以及在會場議程廳外的電子看板。在開發以上項目時，有新點了一些技能點： Nuxt因為這次的官網是用 Nuxt 開發，之前我並沒有使用過，因此一開始在了解架構也花了一點時間，中間也有不小心踩到大坑（也就是在動態路由渲染 head 的部分整個沒帶上參數），幸好同為前端志工的 Mars 耐心的和我講解架構，才順利的完成調整。 Animate 效果這次是第一次用網頁的方式來做電子看板，往年都是用 PPT 的方式呈現，改成網頁的方式好處在於可以動態的更新網頁上的內容，讓對應的時間可以出現議程的預告，真正開始要做的時候大概只剩一個禮拜多一點的時間，當時其實有點緊張，很怕無法時期完成。而為了加速開發，我和後端也一起討論，確定好他那邊怎麼開 API 欄位後，切版與加上功能時也就盡量依照相同邏輯去做，最後相對串接時間也少很多。切版的部分主要碰到比較大量的 animate 製作，對於計算動畫呈現時間、CSS 動畫設定搭配 Animate.css 以及 swiper 輪播套件的應用也算是有蠻大的練習。總之結果我覺得還蠻滿意的！是很有成就感的項目！不知道當天有多少人去看了一下電子看板呢～ Git flow真的不得不說，我的 git 程度提升最多的就是在這時了！我們是 fork MOPCON 的專案，並由 develop 切出所需要開發的功能為 feature開發後也會先 fetch 最新並 rebase 讓分支與遠端的 develop 同步，避免發生衝突，最後 push 上去再發 pull Request 讓組長 review，檢查後沒問題就會被 merge。另外，也會注意每次的 commit 盡量以一個功能為主，也會盡量避免大量的推更新。原來以對 git 的感受僅只在版本控制，但這次還多了多人遠端協作，因此在 git 上就有更多需注意的細節哩 活動當天資訊組的工作大致上會在研討會前完成，因此活動兩天就安排自己想聽的議程，有空閒時間就到攤位幫忙。我是安排第一天的早上幫忙顧攤，來遊戲的人還蠻多的，在顧攤時也有和其他組的人聊聊天，還是覺得這樣的一個活動辦起來真的不容易，大家都投入很多心力呢！透過整個活動下來，我覺得除了培養技術力以外，軟實力的部分也很重要。 議程的部分我聽了五場，這篇就不詳述每個議程細節，在議程中只要沒有標示禁止錄影的場次都會錄影，而且 MOPCON 的共筆文件真的很仔細（根本逐字稿） 傳送門 在看議程時我自己還是會比較傾向一邊做筆記，透過筆記也會更了解講者準備的內容，並紀錄下值得在深入研究的部分。 總結&amp;感謝最後想謝謝洧杰推這個好坑，讓我有機會參與這麼棒的活動，透過活動和大家交流。也謝謝資訊組的大家，真的有感受到寫 code 不孤單，也從中接觸了之前沒碰過的技術並對於遠端協作有進一步的了解。MOPCON 是很用心經營的活動，希望未來大家也可以多多支持！","link":"/2019/10/24/Mine/mopcon-2019/"},{"title":"寫給前端的 Chrome extension 教學","text":"chrome extension 是什麼？chrome extension 也就是在 chrome 瀏覽器中的擴充功能，透過擴充功能 / 插件可以讓我們在使用瀏覽器時獲得某些資訊或是進行某些操作。聽起來有點抽象，來實際說明幾個例子！之前有在 IT 邦幫忙推薦過十個好用的 chrome 插件，傳送門底加：https://ithelp.ithome.com.tw/articles/10204029https://ithelp.ithome.com.tw/articles/10204351以文章提到的 Wappalyzer 來說，透過這個插件就可以取得這個網站所使用到的技術或是插件等等；而以 JSON Viewer 來說，則是可以將資料進行格式化。 總之，這些插件都是掛載在瀏覽器以方便我們進行一些行為，由於 extension 可以在指定網頁中加入額外的內容，所以對於前端來說也是很適合學習且易上手，學會後也可以做各種的運用啦～ 如同在公司有「工具人」之稱的我，為加速工作流程也做過幾個 extension，也因為對 extension 有基礎的了解，而使用插件來輔助搶周興哲演唱會的門票（真的有搶到！！ 話不多說，接下來馬上就開始介紹如何自己製作一個插件吧！ extension 架構簡介extension 是由 manifest.json 以及其他網頁檔案組成的主要架構： Manifest Background Script UI Elements Content Script Options Page manifest.json每個 extension 都要有一個 JSON 格式的清單文件，用來提供重要的資訊。 這邊舉例說明：1234567891011121314151617181920212223242526272829303132333435363738394041{// 必填\"manifest_version\": 2,\"name\": \"ticket extension\",\"version\": \"1\",// 建議\"description\": \"搶票輔助\",// 擇一（browser_action / page_action ）或不填\"browser_action\": { \"default_icon\": \"img/tzu.png\", \"default_title\": \"搶票輔助\"},\"background\": { \"scripts\": [ \"background.js\" ]},// 選填\"options_page\": \"options.html\",\"permissions\": [ \"activeTab\", \"storage\" ],\"content_scripts\" : [{ \"matches\" : [ \"https://tixcraft.com/ticket/ticket/*\" ], \"run_at\": \"document_end\", \"js\" : [ \"jquery.min.js\", \"js/ticket.js\" ]},{ \"matches\" : [ \"https://tixcraft.com/ticket/area/*\" ], \"run_at\": \"document_end\", \"js\" : [ \"jquery.min.js\", \"js/area.js\" ]},{ \"matches\" : [ \"https://tixcraft.com/*\" ], \"run_at\": \"document_end\", \"css\": [\"css/all.css\"], \"js\" : [\"jquery.min.js\", \"js/detail.js\" ]}]} 想了解所有的項目設定清單請看：https://developer.chrome.com/extensions/manifest Background ScriptBackground Script 可以用來對 extension 做事件的監聽，會在觸發事件之後才執行。它僅在需要時才加載。 UI Elements可在 extension 上加上 UI 元素，大多 extension 都會設定 browser action 或是 page action。 兩者的差異： browser_action: 與大部分的網址都會有互動，如下圖： page action: 與特定網址有互動，如下圖： 更多細節設定：https://developer.chrome.com/extensions/user_interface Content Script可以用來讀取或是寫入網頁的 DOM。 另外，也可以運用 Chrome API 來做更多的行為。例如：storage (儲存資料用)先附上 Chrome API 文件介紹 以上三者的關係圖： Options Page可以藉由 Options Page 提供客製化的擴充功能。Options Page 可用從右鍵 &gt; 選項開啟新 tab 來打開頁面也可以透過設定讓 Options Page 用嵌入式的框框打開 新 tab 打開頁面 嵌入式的框框 圖片皆來自 chrome extension 官方文件 以上為 chrome extension 的基礎架構，有個概念之後，接下來會進入實作的介紹並一一運用以上提到的架構內容～ 實作這邊以搶票輔助的插件來做介紹： 使用的情境由於演唱會門票總是秒殺，手速再快都只能看到售完！因此想透過插件省去需要點擊與填寫的步驟，在取到網址時直接完成前面步驟到輸入驗證碼的區塊（還無法透過程式判斷 &amp; 自動填寫驗證碼 QAQ）不過也是省了中間的程序，手速處理驗證碼就可以了 XD 以流程來區分為幾個項目做介紹，主要會介紹在此項目中用了哪些插件相關功能： 設定日期、購買票數、票價區域選擇的設定介面 在節目售票頁面可觀看到目前設定好的項目並觸發搶票 跳轉後會進入選位子的區域，預設會以票價區域選擇取得對應的 url 進行跳轉 進入購票頁面後會自動帶好購買票數與勾選同意條款，並 focus 到驗證碼的 input 1. 設定日期、購買票數、票價區域選擇的設定介面第一個項目會使用到的有 Background Script, UI Elemtents, Options page, Chrome API 首先，extension 的縮圖（如下圖）就是透過上述提過的 UI Elemtents 中的 browser_action 來設定。 在 manifest.json 寫入設定，icon 的部分就使用一般 png 的圖檔，並寫上對應的路徑1234&quot;browser_action&quot;: { &quot;default_icon&quot;: &quot;img/tzu.png&quot;, &quot;default_title&quot;: &quot;搶票輔助&quot;}, 再來是日期、購買票數、票價區域選擇的設定介面，使用 Options page 設定另開頁面的方式來做。 在專案中加入 option.html 並在 manifest.json 的設定1&quot;options_page&quot;: &quot;options.html&quot;, 此時在 extension 按下右鍵 &gt; 選項，就可以開啟 option.html option.html 中就和一般網頁寫的 HTML 檔案一樣，我這邊是用 Bootstrap 設定樣式與把需要的欄位加上，並在最後引入 option.js。而在 option.js 中透過 Chrome API 來儲存項目。舉例來說：在 option.html12345&lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;ProgramDate&quot;&gt;節目日期 :&lt;/label&gt; &lt;input type=&quot;date&quot; id=&quot;ProgramDate&quot; class=&quot;form-control&quot;&gt;&lt;/div&gt;&lt;button id=&quot;save&quot; type=&quot;button&quot; class=&quot;btn btn-info&quot;&gt;儲存設定&lt;/button&gt; option.js1234567891011// 綁定按鈕監聽document.getElementById('save').addEventListener('click', save_options);// save_options 函式中取得 input 值，並用 chrome.strage.local.set 來儲存function save_options() {var ProgramDate = document.getElementById('ProgramDate').value;chrome.storage.local.set({ 'ProgramDate': ProgramDate }, function() { // 完成後要做的事 });} 在使用 Chrome API 要注意： 在 manifest.json 要多加上設定，因為我們是要使用 storage，所以在 permissions 就加上 storage。 1&quot;permissions&quot;: [ &quot;activeTab&quot;, &quot;storage&quot; ], chrome.storage 會分為 storage.sync 和 storage.local， storage.sync 會讓數據保存到 google 帳號。3.chrome.storage.local.set 的資料是物件的類型，例如： 1234{ &apos;key&apos;, value, &apos;ProgramDate&apos;: ProgramDate} 設定好後，因為要開啟 option.html 只能按右鍵 &gt; 選項實在麻煩，所以我們可以透過 Chrome API 來做點擊 extension icon 就打開 option 頁面 這邊需要一個 background.js 來做 Background Script 的設定因此首先先建立 background.js，再使用 chrome.browserAction.onClicked 監聽事件，當 click 的時候就新開 tabs，並導到 option.html 頁面12345chrome.browserAction.onClicked.addListener(tab =&gt; { chrome.tabs.create({ url: chrome.extension.getURL(&quot;options.html&quot;) })}) 在 manifest.json12345&quot;background&quot;: { &quot;scripts&quot;: [ &quot;background.js&quot; ]}, 2. 在節目售票頁面可觀看到目前設定好的項目並觸發搶票使用到的有 Content Script, Chrome API Content Script 用意是在頁面上加入一個寫入一個小區塊並顯示前面設定好的資料和開始取得網頁元素的按鈕。 新增一個 detail.js可用 append 的方式把 html 插入到網頁頁面中，也就是和一般 JS 語法將 html 標籤加入到頁面是一樣的意思，樣式的部分同樣也可以透過 css 設定，再透過 manifest.json 將這個 css 引入。 舉例：123$('body').append(`&lt;div class=\"h_popup_outbox\"&gt;...省略&lt;/div&gt;`); 這樣就可以在視窗上看到如同這樣的畫面 manifest.json 中將需要的檔案加入，透過 matches 可以讓網頁是在這個網址下才取得 css 和 js 檔案。123456{ &quot;matches&quot; : [ &quot;https://tixcraft.com/*&quot; ], &quot;run_at&quot;: &quot;document_end&quot;, &quot;css&quot;: [&quot;css/all.css&quot;], &quot;js&quot; : [&quot;jquery.min.js&quot;, &quot;js/detail.js&quot; ]} 如同上圖中看到，點選『開始搶票』就會觸發函式去抓取售票網頁上的『立即購票』DOM 元素，這邊的抓取 DOM 元素就使用 $(‘className’) 的方式即可～ 若是觸發後有取得 response 則比對設定的日期 (用 Chrome API 處理，下一個項目再說明)，相同則跳轉到取得的 data-href。這一段主要也是 Content Script 做的事情（讀取、寫入網頁 DOM） 3. 跳轉後會進入選位子的區域，預設會以票價區域選擇取得對應的 url 進行跳轉這邊一樣是使用到 Content Script, Chrome API Content Script 因為要針對這頁來抓取座位區域的對應，所以這邊在這個網址下又會新增一個 js 檔案。在 manifest.json 設定更細緻的 matches 就可以了～12345{ &quot;matches&quot; : [ &quot;https://tixcraft.com/ticket/area/*&quot; ], &quot;run_at&quot;: &quot;document_end&quot;, &quot;js&quot; : [ &quot;jquery.min.js&quot;, &quot;js/area.js&quot; ]}, 而第一步設定好的那些內容，就是使用 chrome.storage.local.get，例如：123chrome.storage.local.get([&apos;ProgramSit&apos;, &apos;eventId&apos;], items =&gt; { choosed_sit = `${items.eventId}_${items.ProgramSit}`;}); chrome.storage.local.get 後面是接上陣列資料，陣列裡則是要取出來的 key 值。 4. 進入購票頁面後會自動帶好購買票數與勾選同意條款，並 focus 到驗證碼的 input最後一個流程使用到的就和 2,3 項目相同，都是透過 chrome api GET 設定好的參數，並取得網頁上的 DOM 元素寫入資料。到這一步將驗證碼填好後按下 enter 就送出了！ 實作小結雖然以上說明看起來是落落長，但實際上使用到的技巧到大同小異，了解了插件的結構以及具備前端的基礎技能（HTML, CSS, JavaScript）就能開發出屬於自己的工具了！ 因為目前我所開發過的類型都是偏向簡化網頁上的操作行為，所以在開發插件的時候，首先會先確定好這個插件所要完成的目標為何，並開始設計流程與觀察點擊後觸發的行為。最後再對應回去需要的架構與技巧～ 完整程式碼 為了達成簡化網頁上的操作行為，這邊一定要補充一個我常用的技巧！！ 補充：實用小技巧 - Postman Interceptor這是一個 Postman 的插件，在網頁上開啟它後，它可以取得在網頁的行為，因此當你想了解這個按鈕點下後是 GET 哪支 API 或是 POST 什麼資料出去、需要帶哪些參數，通通告訴你！！插件連結安裝好後，點一下接著就可以在 Postman 中的 history 看到這些行為 插件好處 因為是掛在網站下執行，所以 call api 時可以避免掉 cors 的問題 直接操作網站 DOM 元素，可以將操作介面流程自動化 extension 上架做完插件後，除了可以供給自己使用，也可以透過上架的方式，讓 extension 上到商店提供給其他人下載流程上也非常簡單，只要有 google 帳號，登入開發者頁面後，就可以選擇上傳檔案來上架。 上架需要 5 美金，付完之後就可以無限上架插件，只需要付費一次哦！上架之後也會由 google 進行審核，通過後就可以提供給大家安裝使用囉 流程的部分官方寫得蠻清楚的，附上連結提供參考 總結extension 的開發有蠻大一部分都與前端所需技能相符，因此有興趣的夥伴們也可以嘗試製作自己的插件看看，希望透過這篇文章帶大家認識 chrome extension，若是有開發出好玩的 extension 也歡迎大家跟我分享！ 參考資料https://developer.chrome.com/extensionshttps://ithelp.ithome.com.tw/users/20079450/ironman/1149https://github.com/dsync5566/tixCraftSupport","link":"/2019/10/18/chrome/extension-for-frontend/"},{"title":"快速入門 - TypeScript 的 What? Why? How?","text":"What is TypeScript？1TypeScript = JavaScript + A type System TypeScript 是基於 JavaScript 加上強大的型別系統。 Why use TypeScript? 因為 TypeScript 簡化了 JavaScript，也包含物件導向的概念，因此也提高了程式碼的可讀性和可維護性 TypeScript 會進行型別的檢查，幫助我們在開發時就抓出錯誤並提示，有別於以往 JavaScript 需要運行才能發現錯誤 TypeScript 是開源的 完全相容 JavaScript 語法，可循序漸進的學習 How to start?還沒有安裝環境前，我們可以透過線上的 TypeScript 編譯器來練習 安裝全域安裝 typescript 環境和 ts-node1npm install -g typescript ts-node 安裝 ts-node 是整合 tsc 和 node 指令，讓編譯與運行可以透過一個指令完成。 從簡單練習快速了解 TypeScript這邊的練習主要是從熟悉的 JavaScript 函式帶到一些 TypeScript 語法，讓讀者可以透過簡單的範例內容了解 TypeScript 的益處。 創建資料夾，並新增一個 index.ts 在 index.ts 中寫程式碼（這邊寫的都是 JavaScript 的函式寫法） 1234function starter(word) { console.log('learn TypeScript : ' + word);}starter('Hello World'); 終端運行 tsc index.ts，可以發現資料中多了一個編譯後的 index.js 而再次運行 node index.js 可以發現出現 console.log 的內容 而這邊的第 3 步驟與第 4 步驟也可以改用我們剛剛安裝的 ts-node 直接做 ts 檔案的運行（這個指令不會另外編譯 js 檔案）1ts-node inedex.ts 接下來這一步就會使用到 TypeScript 中的 Type AnnotationsType Annotations 常被翻譯為型別註釋，用來說明變數或是參數的型別。如同下方函式參數，加上型別註釋讓 word 為 string。12345function starter(word: string) { console.log('learn TypeScript : ' + word);}starter('Hello World');starter(true); // error TS2345: Argument of type 'true' is not assignable to parameter of type 'string'. 當呼叫函式並傳入非 string 的值時，就會出現編譯的錯誤訊息。 接著再來體驗一下 TypeScript 中的 InterfacesInterface 常被翻譯為介面或是接口，可用來定義結構化的子類型。1234567891011interface StartData { firstWord: string; lastWord: boolean;}function starterInterface(word: StartData) { console.log('learn TypeScript : ' + word.firstWord + '' + word.lastWord)}starterInterface({ firstWord: 'Hello', lastWord: 'World' })// error TS2322: Type 'string' is not assignable to type 'boolean'. 上面的程式碼編譯後可以發現因為 lastWord 指令的型別是 boolean，但卻傳入字串而出現錯誤。將傳入的內容改為 { firstWord: 'Hello', lastWord: true } 就 ok 啦～ 從以上兩個簡短的範例就可以了解使用 TypeScript 為何可以減低很多不必要的錯誤，讓結構更為嚴謹，在往後維護上也可以更便利。 參考資料：TypeScript 新手指南TypeScript in 5 minutesUdemy - Typescript: The Complete Developer’s Guide 2020","link":"/2020/02/06/w3HexSchool-challenge/TypeScript-get-start/"},{"title":"TypeScript - Interfaces","text":"Interfaces + Classes = TS 提高程式碼複用性。這一篇主要是介紹與了解 Interfaces 的作用，並會在下一篇文章介紹 Classes 與兩者併用的技巧與好處。 InterfacesInterfaces 為物件定義一個新的型別，來描述其屬性名稱與值。在不使用 Interface 以前，我們要用型別註釋來定義物件參數型別，都會寫得很長。但使用 Interfaces 就可以有效解決這個問題。 使用 Interface 來定義物件內的參數型別，就可以直接使用。在以下範例中，只要傳入的內容有符合 Article 所定義的參數與型別即可，不需要依序傳入也沒關係。1234567891011121314interface Article { name: string; page: number; read: boolean;}const articleContent = { name: 'learn', page: 3, read: true}const learnTypeScript = (blog: Article): void =&gt; { console.log(blog.name);}learnTypeScript(articleContent) 函式中，可以傳入 Interface 中沒有定義的變數，但若是沒有傳入必要的參數與型別，則會出現錯誤，例如：(以下範例的 articleContent 少了 read 參數)1234567891011121314151617interface Article { name: string; page: number; read: boolean;}const articleContent = { name: 'learn', page: 3,}const learnTypeScript = (blog: Article): void =&gt; { console.log(blog.name);}learnTypeScript(articleContent) // 錯誤// Argument of type '{ name: string; page: number; }' is not assignable to parameter of type 'Article'.// Property 'read' is missing in type '{ name: string; page: number; }' but required in type 'Article'.(2345) 鋪梗完後，接下來就要介紹 Interfaces 的 Optional Properties (可選屬性) 可選屬性 （Optional Properties）可選屬性可以透過屬性後面加上『？』 來讓參數變成選填。與上面出現錯的範例相同，這邊把 interface 中的 read 後面加上 ? ：12345interface Article { name: string; page: number; read?: boolean;} 再次執行就會發現錯誤消失了，可選屬性可用在定義可有可無的參數上。 另外，Interface 也有提供唯讀屬性： 唯讀屬性（readonly properties）唯讀屬性和 const 定義變數時很像，只能讀取，不能修改變數的值。在 Interface 定義屬性前加上 readonly，就可以讓這個屬性無法被修改1234interface Article { readonly name: string; readonly page: number;} 小補充：const 和 readonly 的差異，在於 const 是針對變數，readonly 則是屬性 了解 Interface 的作用後，回到使用它的核心，也就是要提高程式碼的複用性，因此最後來了解一下 Interface 與函式的結合，寫出提升複用性的程式碼： Interface 中定義 function在 Interface 中也可以定義 function，例如範例中的 getPage()：123456789101112131415161718interface Article { name: string; page: number; read?: boolean; getPage() : string;}const articleContent = { name: 'learn', page: 3, getPage(): string { return `Page: ${this.page} 篇` }}const learnTypeScript = (blog: Article): void =&gt; { console.log(blog.getPage());} 使用 Interface 提高複用性使用一個 Interface 定義 function，並確認函式回傳為 string，當傳入的函式為完全不同的物件（articleContent, newsContent）也是 ok 的。12345678910111213141516171819202122232425interface Page { getPage() : string;}const getPage = (post: Page): void =&gt; { console.log(post.getPage());}const articleContent = { name: 'learn', page: 3, getPage(): string { return `Page: ${this.page} 篇` }}const newsContent = { name: 'Banana 新聞', day: 21, getPage(): string { return `${this.day} 天的新聞` }}getPage(articleContent)getPage(newsContent) 以上的範例程式碼都可以貼到 TypeScript Playground 來運行看看哦～ 參考資料：TypeScript - InterfacesUdemy - Typescript: The Complete Developer’s Guide 2020","link":"/2020/02/27/w3HexSchool-challenge/TypeScript-interfaces/"},{"title":"TypeScript - 資料型別 和 Type Annotations","text":"你是否有打開過某一個專案，發現裡面的變數名稱是 a, b, c 等，完全無法透過變數直接了解其作用？此時若是使用 TypeScript，就可以透過型別的註釋，加速了解正在傳遞的數據類型，進而提高程式碼的可讀性。同理來說，TypeScript 為了規範程式碼，提高維護，會特別著重在型別上，每個值都會有它的型別，而型別也伴隨著它本身帶有的方法，例如：string 有 indexOf()。 TypeScript 資料型別前幾個都為 JavaScript 的原始型別（Primitive Types），在 TypeScript 同樣也有這些資料型別。我們就透過型別注釋的方式一一介紹： Boolean1let learn: boolean = true; 因為 learn 已經是 Boolean，所以不能再將這個變數的值改為數值。12learn = 123; // 錯誤learn = false; //正確 Number數值類型支援浮點數、也可以使用十六進位、二進位、八進位。1234let decimal: number = 5;let hex: number = 0xf00d;let binary: number = 0b1010;let octal: number = 0o744; String12let str:string = 'learn typescript';str = 'TypeScript'; 字串也可以改用模板字符串12let count: number = 2;let sentence: string = `這是第 ${count} 篇文`; 這樣也就等於是1let sentence: string = '這是第' + count + '篇文'; null123let num: null;num = 1; // 錯誤num = null; // 正確 undefined12345let test: number;console.log(test); // 錯誤let test2: undefined;console.log(test2); // 正確 voidJavaScript 沒有 void（可視為空值），但是在 TypeScript 中，可以用 void 來表示沒有任何 return (返回值) 的函式。1234function fn () { console.log('learn TypeScript');}fn(); Array陣列的寫法有兩種：第一種是「型別 + 方括號」表示法，例如：number[]12let list: number[] = [1, '2', 3]; // 錯誤let list2: number[] = [1, 2, 3]; // 正確 第二種則是陣列泛型（Array Generic）Array&lt;型別&gt; 來表示：12let list: Array&lt;number&gt; = [1, '2', 3]; // 錯誤let list2: Array&lt;number&gt; = [1, 2, 3]; // 正確 ObjectObject 是物件型別，也表示非原始型別（Boolean、Number、String、null、undefined）12let obj: object;obj = {name: 'Tzu Hui', age: 25}; 或是可以將物件內的參數一一定義型別123456789let obj: { name: string, age: number,}; obj = { name: 'Tzu Hui', age: 25}; TupleTuple 是指元素陣列，Tuple 可以以固定的數量定義陣列中位置的型別1let tupleArr: [number, string, boolean] = [2, '寫文啦', true]; 如同一開始提到型別都會有自己可用的方法，因此在這邊也是會有相對應12console.log(tupleArr[1].substring(1)); // 正確console.log(tupleArr[0].substring(1)); // 錯誤，因為 number 沒有 substring 方法 EnumEnum 常被翻譯為列舉型別，用於定義一定範圍內的值。如以下範例，將三種狀態利用 enum 做定義。在預設沒有賦予值的情況下，enum 會給這些變數對應的數字值，也就是 0, 1, 2, 3 以此類推。12345enum statusCode { success, fail, pending}; 上面這段在編譯後為：123456var statusCode;(function (statusCode) { statusCode[statusCode[\"success\"] = 0] = \"success\"; statusCode[statusCode[\"fail\"] = 1] = \"fail\"; statusCode[statusCode[\"pending\"] = 2] = \"pending\";})(statusCode || (statusCode = {})); 12let res:statusCode = statusCode.success;console.log(res); // 0 那當有賦予值時，沒有賦予值得變數仍會依照前一個變數的值往後推 +11234567enum statusCode { success = 7, fail, pending};let res:statusCode = statusCode.fail;console.log(res); // 8 也可用數字反推12let status: string = statusCode[8];console.log(status); // fail 以上介紹是 Enums 的 Numeric enums，Enums 仍有 String enums、Ambient Enums 等內容，之後再做一篇更深入的介紹。 AnyAny 為任意型別，也就是不指定型別。在指定型別下，變數是所賦予的值是必須符合型別，但指定為 Any 時則可以自由切換指定 string 的範例：12let toDayPage: string = 'two';toDayPage = 2; // 錯誤 改為 Any 的範例：12let toDayPage: any = 'two';toDayPage = 2; // 正確 Any 除了可以更換值的型別以外，設為 Any 後還可以取得屬性與方法例如：123let anyThing: any = 'blog';console.log(anyThing.page);console.log(anyThing.page.count); 最後還要注意一個小地方：因為 TypeScript 會做型別推論，但是當一開始變數沒有賦予值的話，就會定為 Any 型別。12let toDayPage = 'two';toDayPage = 2; // 錯誤 下方與上方的例子差別在於，上方 toDayPage 一開始就賦予字串值，而下方式只有定義，因此在更改 toDayPage = 2 時，只有下方的 Any 不會出現錯誤，上方的則是因為型別推論被當成 string 類型而不能修改其他型別值。1234let toDayPage: any;toDayPage = 'two';toDayPage = 2; // 正確toDayPage.getPage('two'); Nevernever 是代表不會出現的類型，可以用在 throw new Error。當使用 Never 時是不可以對變數賦予其他類型的值。123456let test: never;test = 'learn'; // 錯誤function error(message: string): never { throw new Error(message);} 小補帖 - 型別推論（Type Inference）在 Any 的段落有提到 TypeScript 有型別推論。型別推論是 TypeScript 透過賦予的值，自動判斷該變數的型別，因此不需要做型別註釋也是可以正確執行的。 例如：123let page = 2;page = 'two' // 錯誤// 因為型別推論已將 page 的型別定為 Number，因此不能再賦予他 String 參考資料：TypeScript - Basic TypesUdemy - Typescript: The Complete Developer’s Guide 2020基礎 - TypeScript 新手指南Typescript 學習筆記二：資料型別","link":"/2020/02/15/w3HexSchool-challenge/TypeScript-type-intro/"},{"title":"gulp 3 遷移至 gulp 4","text":"從 2018 年 10 月開始，使用 npm 下載 gulp 預設的版本都將為 4，因 gulp 3 與 4 在寫法上有些更新，所以在安裝 4 的情況之下，運行 3 的寫法是有可能會出錯的，因此這篇主要說明 gulp 3 與 4 的差異 若仍需要使用 gulp 3，也可以用此指令安裝 3 的版本1npm install gulp@^3.9.1 使用 series() 取代原本 Arrays 任務安排的寫法Gulp 4 介紹了新的組合任務方法：series()、parallel() series() 按指定的順序一次運行一個任務parallel() 以任何順序同時運行任務 舉例：在 gulp 31gulp.task(&apos;default&apos;, [&apos;browserSync&apos;]); 轉換到 gulp 41gulp.task(&apos;default&apos;, gulp.series(&apos;browserSync&apos;)) 兩者也可以混用，例如：1gulp.task(&apos;build&apos;, gulp.series(&apos;clean&apos;, gulp.parallel(&apos;sass&apos;, &apos;vendorJs&apos;))); 這樣的寫法也是先執行 clean 後再執行後面的 sass, vendorJS而 sass, vendorJS 是同時執行的 使用 done() - 當任務結束後的 callback12345678gulp.task(&apos;default&apos;, gulp.series(&apos;clean&apos;, gulp.parallel(&apos;sass&apos;, &apos;vendorJs&apos;), function(done) { // 也就是先確保前面都執行完 gulp.watch([&apos;./source/stylesheets/**/*.sass&apos;, &apos;./source/stylesheets/**/*.scss&apos;],gulp.series(&apos;sass&apos;)); done(); })); 模組化設計 - 將 task 改用一般的函式寫法好處在於可以更方便的管理使用。 另外建立一個 JS 檔 (ex: vendor.js )，並將 task 改用函式的方式來寫 舉例：12345678gulp.task(&apos;vendorJs&apos;, function () { return gulp.src([ &apos;./node_modules/jquery/dist/jquery.slim.min.js&apos;, &apos;./node_modules/bootstrap/dist/js/bootstrap.bundle.min.js&apos; ]) .pipe($.concat(&apos;vendor.js&apos;)) .pipe(gulp.dest(&apos;./public/javascripts&apos;))}) 改用函式的寫法：12345678910const vendorJs = function(done) { gulp.src([ &apos;./node_modules/jquery/dist/jquery.slim.min.js&apos;, &apos;./node_modules/bootstrap/dist/js/bootstrap.bundle.min.js&apos; ]) .pipe($.concat(&apos;vendor.js&apos;)) .pipe(gulp.dest(&apos;./public/javascripts&apos;)) done();};exports.vendorJs = vendorJs; 在原本的 JS 檔（主要安排與執行任務的檔案，ex: index.js）將上面寫好的檔案引入 1const { vendorJs } = require(&apos;./vendor.js&apos;); 最後將 vendorJs 安排到任務執行 1gulp.series(vendorJs) 要注意因為是引入的方法，所以這邊安排任務不是使用字串 '' 寫法","link":"/2019/08/29/JavaScript/gulp/gulp3-to-4/"},{"title":"Lottie 輕鬆實現動畫效果","text":"Lottie 是 Airbnb 開源的跨平台動畫函式庫，設計師可以透過 Adobe After Effects 做出動畫後，經由一個 Bodymovin 的擴充功能輸出 JSON 格式。接著再由工程師透過 Lottie 函式庫讀取 JSON 資料來呈現出動畫。 Lottie 官網：http://airbnb.io/lottie/#/這篇主要說明在 Web 使用 Lottie：https://github.com/airbnb/lottie-web 實作首先可以在 Lottie 官網的動畫分類找到很多設計師的作品，從中選擇一個來實作看看吧！ 載入 Lottie 資源 CDN1https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.5.9/lottie.min.js npm1npm install lottie-web 初始化 將下面程式碼加入，並加入對應的參數資料就可以啟用了123456lottie.loadAnimation({ wrapper: svgContainer, animType: 'svg', loop: true, path: 'https://assets4.lottiefiles.com/packages/lf20_Sjy4Vl.json'}); container: 對應的 HTML 元素 id animationData: 動畫的 JSON 資料 path: 動畫的 JSON 資料來源 (animationData、path 擇一使用即可) loop: 循環播放 (true / false / number) autoplay: 自動播放（true / false） name: 名稱 renderer: 設置渲染器（’svg’ / ‘canvas’ / ‘html’） 預設使用 svg 渲染 差異： svg：元素使用 svg 呈現，動畫效果透過 svg 的動畫來做 canvas：元素使用 canvas 繪製，透過定時刷新重繪呈現動畫效果 html：元素使用 svg 呈現，動畫效果透過 CSS 的動畫來做 除了基礎的參數以外，還有許多事件可以設置 (播放、暫停、播放速度等等)，使用方式舉例：1234567const anlottie = lottie.loadAnimation({ container: svgContainer, animType: 'svg', loop: true, path: 'https://assets4.lottiefiles.com/packages/lf20_Sjy4Vl.json',});anlottie.setSpeed(6); 透過 setSpeed() 就可以加快動畫的速度。常用也包括 play()、stop()、pause(); 可設置參數詳細內容可參考這裡：https://airbnb.io/lottie/#/web?id=usage-1 Demo 使用 Lottie 好處1. 清晰在任何高分辨率顯示器上就能看出差異。點我觀看 2. 輕巧同樣使用呈現動畫的 gif 圖片來說，一個 JSON 檔案會小許多。 3. 方便方便的呈現複雜動畫效果，不用寫很多 code 來處理，只要提供對應的 JSON 動畫資源即可。 小結要在網頁上呈現複雜動畫時，可以試著用 Lottie 來完成哦！","link":"/2019/09/26/JavaScript/lottie/lottie-intro/"},{"title":"用範例理解 JS Promise","text":"Promise 的好用之處在於，可以確保事件完成後再執行後面的行為，也解決了傳統 callback 波動拳的問題。它用 resolve, reject 來傳遞函式執行後為成功或是失敗的訊息，再用 then 與 catch 來做對應處理。這一篇就用範例快速了解一下 Promise 怎麼用吧！ 情境舉例：當我要去旅遊，首先必須先整理行李後才能出發，因此行李整理完成，我才會叫車 Promise 基礎範例123456789101112131415function checkLuggage() { return new Promise((resolve, reject) =&gt; { if (parseInt(Math.random() * 2)) { // 隨機 setTimeout(resolve, 10000 * Math.random(), '收好行李'); // 隨機時間（不知道要收多久的概念） } else { reject('想慢慢收') } })}checkLuggage().then((data)=&gt; { console.log(data, '可以叫車了！');}).catch((err)=&gt; { console.log(err, '先不要叫車')}); 迴圈與 Promise, Promise.all 的運用Promise.all() 這個方法可以同時執行很多 Promise，並在全部都執行完後回傳。 情境舉例：繼續上一個情境，整理行李要拿的東西實在太多假設我只要發送指令，就可以讓機器人自動去幫我做拿好（做夢那整理行李這件事，我就可以個別發送『拿衣服』、『拿褲子』、『拿襪子』指令，讓他們去拿 XD當我發送出指令的時候，我總要知道他們哪時候完成，才方便我打電話叫車嘛～此時就可以用 promise.all 來確定事情完成： 先制定好去拿的這個事件，並在完成拿取時回報完成 123456let todos = ['拿衣服', '拿褲子', '拿襪子'];function getThing(todo) { // 拿東西都是相同指令，就用同一個函式就可以了 return new Promise((resolve, reject) =&gt; { setTimeout(resolve, 10000 * Math.random(), todo+'完成'); })} 接著用 checkLuggage 來統一發送與接受完成的回傳： 123456789101112function checkLuggage() { return new Promise((resolve, reject) =&gt; { let allTodo = []; // 用一個變數將所有 promise 事件推進去 todos.forEach(todo =&gt; { allTodo.push(getThing(todo)); }) Promise.all(allTodo).then((results) =&gt; { const msg = '全部完成：'+ results; resolve(msg); }) });} 最後執行 checkLuggage 函式，等到全部事情都完成了才會執行 callForCar 函式 1234567function callForCar() { console.log('叫車')}checkLuggage().then(data =&gt; { console.log(data) callForCar();}); 這個方法常使用在不確定陣列中（如同範例的 todos）有多少個項目，直接透過迴圈的方式紀錄所有 promise 事件。當其中一個為失敗的話，也可以使用 catch 來做取得錯誤後的處理。這部分就和一開始的 Promise 基礎範例是一樣的道理～ 小結透過 Promise 就可以確保事件完成後才觸發後面要執行的事項。就不會發生行李還沒整理好，車子就來了的情形啦！","link":"/2019/12/27/JavaScript/JS/js-promise/"},{"title":"在專案引入 gulp 4.0 並開啟 Ｗeb Server (使用 browser-sync)","text":"這篇是使用 gulp 4，所以使用 gulp 3 要注意 task 安排的寫法正文開始！這一篇要從資料夾中只含有一個 index.html 檔案開始說起 1. 初始化套件管理器 ( NPM )1npm init 下指令後會有一些需要輸入的內容，懶人建立就都按 Enter 就好完成後資料夾中就會有 package.json 檔案了 2. 新增一個 JS 檔案ex: gulpfile.js用來加入 gulp 任務 3. require gulp 模組在終端機下指令1npm install gulp 在 gulpfile.js 寫入1const gulp = require(&apos;gulp&apos;); 引入 gulp 後可以使用 gulp.task 來執行任務例如：1gulp.task(&apos;default&apos;, gulp.series(&apos;browserSync&apos;)) 在 gulp4 中可使用 gulp.series() 和 gulp.parallel() 來安排任務進行 gulp.series() -&gt; 按照順序進行gulp.parallel() -&gt; 同時進行'default' -&gt; 任務名稱'browserSync' -&gt; 任務的內容 了解任務要如何安排後，接下來要安裝用來開始 web server 的套件 - browser-sync 4. 載入 browser-sync 套件在終端機下指令安裝 browser-sync1npm install browser-sync 在 gulpfile.js 寫入1const browserSync = require(&apos;browser-sync&apos;); 5. 使用 browserSync 所提供的方法來 init參考寫法：1234567gulp.task(&apos;browserSync&apos;, function () { browserSync.init({ server: { baseDir: &apos;./&apos;, // 指向要開啟的資料夾 }, })}); 6. 執行 gulp 就可以順利開啟 web server 啦小補充1 - 運用 gulp watch() 讓檔案有更動時自動 reloadgulp watch 是用於監看全局任務，因此可以用於當檔案發生改變時觸發某行為例如：1gulp.watch(&quot;*.html&quot;).on(&quot;change&quot;, browserSync.reload); 也就是當 HTML 檔案有更動時，在儲存的同時 web server 也會 reload，這樣在開發上就更方便啦～ 小補充2 - 在 gulp4 中任務也可以用函式的方式來寫，並用 export 匯出12345678910function browser() { browserSync.init({ server: { baseDir: &apos;./&apos;, }, }) gulp.watch(&apos;*.html&apos;).on(&apos;change&apos;, browserSync.reload);}exports.default = gulp.series(browser); 更多 browser-sync 使用方法請見：https://browsersync.io/docs/gulp#gulp-install","link":"/2019/08/17/JavaScript/gulp/gulp-browserSync/"},{"title":"初探前端 Unit Test","text":"上上個禮拜參加 MOPCON 2019 時，聽到神 Q 超人介紹了『我們與測試的距離』，當時他問了在場的會眾說：『有聽過單元測試的舉手？』現場大概有八成的人都舉手了，接著他再問：『有在前端導入測試的舉手？』結果很意外的，居然幾乎沒有人舉手！我想這應該是因為目前大多數的前端開發還是都以人工進行測試比較多。隨著專案當規模變大時，在產品上線前都會進行多次人工的測試，或是進行程式碼的重構，這都是常見的現象。但也經常因為重構或是測試後進行調整時出現改 A 壞 B 的情況，又或者花在人工測試的時間太多，因此這時就可以試著導入單元測試來輔助開發過程。 何謂單元測試？以 function 為最小單位，程式裡每個單一行為，可稱為一個單元。例如： 按下按鈕事件觸發 API function 執行與回傳 而單元測試則是利用貼近實際使用的腳本來進行對程式碼的檢查與驗證，確保函式的輸入輸出結果是符合需求且可以正確運行的。 單元測試的好處 提高正確性：透過測試可以對於功能輸入輸出有個快速的回饋，開發時也可以驗證函式邏輯與想法。 隨時可測試隨時都可以開啟測試，不一定要等到功能完全寫完後才進行人工的測試，當其中出現問題時，還需要一一驗證是哪個環節出問題。 花費時間短透過自動化重複測試的部分，不需要一再進行耗時的重複人工測試。 測試後能產生測試報告（覆蓋率報告）透過單元測試的工具，可以輸出測試後的測試報告，也包含此次測試所覆蓋的程式碼驗證程度，讓測試不會口說無憑！ 兩個常被提到的單元測試面向 - TDD &amp; BDDTDD（Test-driven development）測試驅動開發TDD 是在開發前先寫測試的程式碼，由通過測試來推動開發的進行。 TDD 的主要運行圖：圖片引用自 hybrid-development-with-tdd-ddd-bdd 從圖中可看出 TDD 的運作是『紅燈』(Red)、『綠燈』(Green)、『綠燈』(Refactor) 的循環。 這個循環也可以簡單的分為 6 個步驟： 1. 分析需求、思考實作：根據需求取設計一個自動化的測試實例。 2. 運行所有測試：在目前開發的程式碼上運行這些自動化測試。在此階段通常會出現紅燈（因為根本還沒開始開發嘛～～～） 3. 開發符合測試需求的程式碼以功能邏輯為主進行開發，並使其通過測試案例 4. 再次運行測試，並確認是否通過測試首先要確保功能的開發是否有正確得到實作，若是通過測試（綠燈）代表大致上已經完成一個可正確運行的版本。 5. 重構這個步驟是可做可不做，但重構可以提高程式碼品質以及提升複用性。 6. 重複以上步驟有新的測試（對應每個功能）都可以重複步驟 1-5，直到所以測試都通過。 流程圖參考：圖片來自 TDD Vs BDD – Analyze The Differences With Examples 使用 TDD 的方式，就好像是腳踏車的輪子，都是向同一個方向轉動（相同專案需求目標），但後輪是施力的讓腳踏車往前，而前輪是受力的，被帶動而轉（測試驅動開發）。 TDD 實例可以參考這篇文章 TDD 開發五步驟 中提到的『TDD 模式示範』。 BDD（Behavior-driven development）行為驅動開發BDD 的主要目標是以行為為導向去寫測試，透過利益相關者又或者是專案成員（開發人員、測試人員、用戶）描述系統功能和業務邏輯，來了解預期對系統的需求與認知，進而根據這些描述來進行系統自動化的測試。 BDD 流程： 1. 根據 user story 定義出具體的目標： Given（上下文，如：環境條件、情境先決條件） When（事件、當下的動作） Then（預期結果、其他結果） 例如： Given 有個顧客擁有一個銀行帳戶When 顧客要從帳戶中轉帳到海外帳戶Then 這筆帳轉到海外帳戶And 並從這個帳戶中收取轉帳的小費 2. 將定義出的敘述轉為程式碼 BDD 的過程可以參考這一篇文章 自動軟體測試 中 BDD (Behavior-driven development)這邊有舉出 BDD 實例。 總結 TDD 與 BDD 差異BDD 和 TDD 有個各自適用的情境，TDD 在於高效且快速開發並測試功能模組，在開發前先寫測試，以確保程式碼品質與符合需求的結果。BDD 比較偏向於系統功能與業務邏輯的自動化測試，除了實作前先寫測試外，通常還會產出一分執行規格。因為強調的是系統行為，因此也會減少使用者和工程師的溝通成本。 測試工具入門初體驗以上講了這麼多觀念，當然要搭配程式碼來理解一下！這邊使用 Jest 來初步做一個簡單的測試。 在專案中載入 Jest 1npm install jest 在專案中加入 sum.js寫入一個加總的函式，讓函式返回結果為 a+b 123456789let math = { sum: function(a, b) { return a + b; }, minus: function(a, b) { return a - b; }}module.exports = math; 在專案中加入 sum.test.jstest 的 js 中需要將要測試的函式 require 進來，接著寫下要測試的內容，並寫在預期測試的結果。 123456789const math = require(&apos;./sum&apos;);test(&apos;adds 1 + 2 to equal 3&apos;, () =&gt; { expect(math.sum(1, 2)).toBe(3);});test(&apos;minus 4 - 2 to equal 2&apos;, () =&gt; { expect(math.minus(4, 2)).toBe(2);}); 在 package.json 加入 test 123&quot;scripts&quot;: { &quot;test&quot;: &quot;jest&quot;}, 運行 npm run test 看結果如果 test 成功會出現如下圖 我們試著將函式修改一下(假裝不小心把 return 結果寫相反)，例如：123456sum: function(a, b) { return a - b;},minus: function(a, b) { return a + b;} 那運行測試的結果一定是錯誤的，接著就會看到如下圖： 本文小結這篇主要著重於了解單元測試的基礎觀念，接下來持續往實作的方向做介紹。初步開始了解單元測試，若是文章中的解釋有誤，再請多多指教 :D 參考文獻認識軟體測試的世界 &amp; TDD/BDD 入門前端單元測試Unit Test浅谈前端单元测试單元測試：Mocha、Chai 和 Sinon","link":"/2019/10/31/JavaScript/unit-test/unit-test-basic/"}],"tags":[{"name":"git","slug":"git","link":"/tags/git/"},{"name":"技術筆記","slug":"技術筆記","link":"/tags/技術筆記/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"問答小坑","slug":"問答小坑","link":"/tags/問答小坑/"},{"name":"Bootstrap","slug":"Bootstrap","link":"/tags/Bootstrap/"},{"name":"六角","slug":"六角","link":"/tags/六角/"},{"name":"MOPCON","slug":"MOPCON","link":"/tags/MOPCON/"},{"name":"chrome extension","slug":"chrome-extension","link":"/tags/chrome-extension/"},{"name":"w3HexSchool","slug":"w3HexSchool","link":"/tags/w3HexSchool/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"gulp","slug":"gulp","link":"/tags/gulp/"},{"name":"lottie","slug":"lottie","link":"/tags/lottie/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"Unit Test","slug":"Unit-Test","link":"/tags/Unit-Test/"}],"categories":[{"name":"Git 筆記","slug":"Git-筆記","link":"/categories/Git-筆記/"},{"name":"Vue 筆記","slug":"Vue-筆記","link":"/categories/Vue-筆記/"},{"name":"CSS 筆記","slug":"CSS-筆記","link":"/categories/CSS-筆記/"},{"name":"HTML 筆記","slug":"HTML-筆記","link":"/categories/HTML-筆記/"},{"name":"Bootstrap 筆記","slug":"Bootstrap-筆記","link":"/categories/Bootstrap-筆記/"},{"name":"葉子漂流記","slug":"葉子漂流記","link":"/categories/葉子漂流記/"},{"name":"Chrome","slug":"Chrome","link":"/categories/Chrome/"},{"name":"JS","slug":"JS","link":"/categories/JS/"},{"name":"gulp","slug":"gulp","link":"/categories/gulp/"}]}