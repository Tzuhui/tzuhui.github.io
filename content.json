{"meta":{"title":"想飛的葉子","subtitle":null,"description":null,"author":"TzuHui Yeh","url":"https://tzuhui.github.io"},"pages":[{"title":"About","date":"2019-09-26T17:59:11.691Z","updated":"2019-09-26T17:59:11.691Z","comments":true,"path":"about/index.html","permalink":"https://tzuhui.github.io/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2019-05-20T15:12:49.730Z","updated":"2018-10-26T03:21:38.679Z","comments":true,"path":"categories/index.html","permalink":"https://tzuhui.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-05-20T15:12:49.732Z","updated":"2018-10-26T03:21:38.679Z","comments":true,"path":"tags/index.html","permalink":"https://tzuhui.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"寫給前端的 Chrome extension 教學","slug":"chrome/extension-for-frontend","date":"2019-10-17T16:00:00.000Z","updated":"2019-10-17T17:43:43.960Z","comments":true,"path":"2019/10/18/chrome/extension-for-frontend/","link":"","permalink":"https://tzuhui.github.io/2019/10/18/chrome/extension-for-frontend/","excerpt":"chrome extension 是什麼？chrome extension 也就是在 chrome 瀏覽器中的擴充功能，透過擴充功能 / 插件可以讓我們在使用瀏覽器時獲得某些資訊或是進行某些操作。聽起來有點抽象，來實際說明幾個例子！","text":"chrome extension 是什麼？chrome extension 也就是在 chrome 瀏覽器中的擴充功能，透過擴充功能 / 插件可以讓我們在使用瀏覽器時獲得某些資訊或是進行某些操作。聽起來有點抽象，來實際說明幾個例子！之前有在 IT 邦幫忙推薦過十個好用的 chrome 插件，傳送門底加：https://ithelp.ithome.com.tw/articles/10204029https://ithelp.ithome.com.tw/articles/10204351以文章提到的 Wappalyzer 來說，透過這個插件就可以取得這個網站所使用到的技術或是插件等等；而以 JSON Viewer 來說，則是可以將資料進行格式化。 總之，這些插件都是掛載在瀏覽器以方便我們進行一些行為，由於 extension 可以在指定網頁中加入額外的內容，所以對於前端來說也是很適合學習且易上手，學會後也可以做各種的運用啦～ 如同在公司有「工具人」之稱的我，為加速工作流程也做過幾個 extension，也因為對 extension 有基礎的了解，而使用插件來輔助搶周興哲演唱會的門票（真的有搶到！！ 話不多說，接下來馬上就開始介紹如何自己製作一個插件吧！ extension 架構簡介extension 是由 manifest.json 以及其他網頁檔案組成的主要架構： Manifest Background Script UI Elements Content Script Options Page manifest.json每個 extension 都要有一個 JSON 格式的清單文件，用來提供重要的資訊。 這邊舉例說明：1234567891011121314151617181920212223242526272829303132333435363738394041&#123;// 必填\"manifest_version\": 2,\"name\": \"ticket extension\",\"version\": \"1\",// 建議\"description\": \"搶票輔助\",// 擇一（browser_action / page_action ）或不填\"browser_action\": &#123; \"default_icon\": \"img/tzu.png\", \"default_title\": \"搶票輔助\"&#125;,\"background\": &#123; \"scripts\": [ \"background.js\" ]&#125;,// 選填\"options_page\": \"options.html\",\"permissions\": [ \"activeTab\", \"storage\" ],\"content_scripts\" : [&#123; \"matches\" : [ \"https://tixcraft.com/ticket/ticket/*\" ], \"run_at\": \"document_end\", \"js\" : [ \"jquery.min.js\", \"js/ticket.js\" ]&#125;,&#123; \"matches\" : [ \"https://tixcraft.com/ticket/area/*\" ], \"run_at\": \"document_end\", \"js\" : [ \"jquery.min.js\", \"js/area.js\" ]&#125;,&#123; \"matches\" : [ \"https://tixcraft.com/*\" ], \"run_at\": \"document_end\", \"css\": [\"css/all.css\"], \"js\" : [\"jquery.min.js\", \"js/detail.js\" ]&#125;]&#125; 想了解所有的項目設定清單請看：https://developer.chrome.com/extensions/manifest Background ScriptBackground Script 可以用來對 extension 做事件的監聽，會在觸發事件之後才執行。它僅在需要時才加載。 UI Elements可在 extension 上加上 UI 元素，大多 extension 都會設定 browser action 或是 page action。 兩者的差異： browser_action: 與大部分的網址都會有互動，如下圖： page action: 與特定網址有互動，如下圖： 更多細節設定：https://developer.chrome.com/extensions/user_interface Content Script可以用來讀取或是寫入網頁的 DOM。 另外，也可以運用 Chrome API 來做更多的行為。例如：storage (儲存資料用)先附上 Chrome API 文件介紹 以上三者的關係圖： Options Page可以藉由 Options Page 提供客製化的擴充功能。Options Page 可用從右鍵 &gt; 選項開啟新 tab 來打開頁面也可以透過設定讓 Options Page 用嵌入式的框框打開 新 tab 打開頁面 嵌入式的框框 圖片皆來自 chrome extension 官方文件 以上為 chrome extension 的基礎架構，有個概念之後，接下來會進入實作的介紹並一一運用以上提到的架構內容～ 實作這邊以搶票輔助的插件來做介紹： 使用的情境由於演唱會門票總是秒殺，手速再快都只能看到售完！因此想透過插件省去需要點擊與填寫的步驟，在取到網址時直接完成前面步驟到輸入驗證碼的區塊（還無法透過程式判斷 &amp; 自動填寫驗證碼 QAQ）不過也是省了中間的程序，手速處理驗證碼就可以了 XD 以流程來區分為幾個項目做介紹，主要會介紹在此項目中用了哪些插件相關功能： 設定日期、購買票數、票價區域選擇的設定介面 在節目售票頁面可觀看到目前設定好的項目並觸發搶票 跳轉後會進入選位子的區域，預設會以票價區域選擇取得對應的 url 進行跳轉 進入購票頁面後會自動帶好購買票數與勾選同意條款，並 focus 到驗證碼的 input 1. 設定日期、購買票數、票價區域選擇的設定介面第一個項目會使用到的有 Background Script, UI Elemtents, Options page, Chrome API 首先，extension 的縮圖（如下圖）就是透過上述提過的 UI Elemtents 中的 browser_action 來設定。 在 manifest.json 寫入設定，icon 的部分就使用一般 png 的圖檔，並寫上對應的路徑1234&quot;browser_action&quot;: &#123; &quot;default_icon&quot;: &quot;img/tzu.png&quot;, &quot;default_title&quot;: &quot;搶票輔助&quot;&#125;, 再來是日期、購買票數、票價區域選擇的設定介面，使用 Options page 設定另開頁面的方式來做。 在專案中加入 option.html 並在 manifest.json 的設定1&quot;options_page&quot;: &quot;options.html&quot;, 此時在 extension 按下右鍵 &gt; 選項，就可以開啟 option.html option.html 中就和一般網頁寫的 HTML 檔案一樣，我這邊是用 Bootstrap 設定樣式與把需要的欄位加上，並在最後引入 option.js。而在 option.js 中透過 Chrome API 來儲存項目。舉例來說：在 option.html12345&lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;ProgramDate&quot;&gt;節目日期 :&lt;/label&gt; &lt;input type=&quot;date&quot; id=&quot;ProgramDate&quot; class=&quot;form-control&quot;&gt;&lt;/div&gt;&lt;button id=&quot;save&quot; type=&quot;button&quot; class=&quot;btn btn-info&quot;&gt;儲存設定&lt;/button&gt; option.js1234567891011// 綁定按鈕監聽document.getElementById('save').addEventListener('click', save_options);// save_options 函式中取得 input 值，並用 chrome.strage.local.set 來儲存function save_options() &#123;var ProgramDate = document.getElementById('ProgramDate').value;chrome.storage.local.set(&#123; 'ProgramDate': ProgramDate &#125;, function() &#123; // 完成後要做的事 &#125;);&#125; 在使用 Chrome API 要注意： 在 manifest.json 要多加上設定，因為我們是要使用 storage，所以在 permissions 就加上 storage。 1&quot;permissions&quot;: [ &quot;activeTab&quot;, &quot;storage&quot; ], chrome.storage 會分為 storage.sync 和 storage.local， storage.sync 會讓數據保存到 google 帳號。3.chrome.storage.local.set 的資料是物件的類型，例如： 1234&#123; &apos;key&apos;, value, &apos;ProgramDate&apos;: ProgramDate&#125; 設定好後，因為要開啟 option.html 只能按右鍵 &gt; 選項實在麻煩，所以我們可以透過 Chrome API 來做點擊 extension icon 就打開 option 頁面 這邊需要一個 background.js 來做 Background Script 的設定因此首先先建立 background.js，再使用 chrome.browserAction.onClicked 監聽事件，當 click 的時候就新開 tabs，並導到 option.html 頁面12345chrome.browserAction.onClicked.addListener(tab =&gt; &#123; chrome.tabs.create(&#123; url: chrome.extension.getURL(&quot;options.html&quot;) &#125;)&#125;) 在 manifest.json12345&quot;background&quot;: &#123; &quot;scripts&quot;: [ &quot;background.js&quot; ]&#125;, 2. 在節目售票頁面可觀看到目前設定好的項目並觸發搶票使用到的有 Content Script, Chrome API Content Script 用意是在頁面上加入一個寫入一個小區塊並顯示前面設定好的資料和開始取得網頁元素的按鈕。 新增一個 detail.js可用 append 的方式把 html 插入到網頁頁面中，也就是和一般 JS 語法將 html 標籤加入到頁面是一樣的意思，樣式的部分同樣也可以透過 css 設定，再透過 manifest.json 將這個 css 引入。 舉例：123$('body').append(`&lt;div class=\"h_popup_outbox\"&gt;...省略&lt;/div&gt;`); 這樣就可以在視窗上看到如同這樣的畫面 manifest.json 中將需要的檔案加入，透過 matches 可以讓網頁是在這個網址下才取得 css 和 js 檔案。123456&#123; &quot;matches&quot; : [ &quot;https://tixcraft.com/*&quot; ], &quot;run_at&quot;: &quot;document_end&quot;, &quot;css&quot;: [&quot;css/all.css&quot;], &quot;js&quot; : [&quot;jquery.min.js&quot;, &quot;js/detail.js&quot; ]&#125; 如同上圖中看到，點選『開始搶票』就會觸發函式去抓取售票網頁上的『立即購票』DOM 元素，這邊的抓取 DOM 元素就使用 $(‘className’) 的方式即可～ 若是觸發後有取得 response 則比對設定的日期 (用 Chrome API 處理，下一個項目再說明)，相同則跳轉到取得的 data-href。這一段主要也是 Content Script 做的事情（讀取、寫入網頁 DOM） 3. 跳轉後會進入選位子的區域，預設會以票價區域選擇取得對應的 url 進行跳轉這邊一樣是使用到 Content Script, Chrome API Content Script 因為要針對這頁來抓取座位區域的對應，所以這邊在這個網址下又會新增一個 js 檔案。在 manifest.json 設定更細緻的 matches 就可以了～12345&#123; &quot;matches&quot; : [ &quot;https://tixcraft.com/ticket/area/*&quot; ], &quot;run_at&quot;: &quot;document_end&quot;, &quot;js&quot; : [ &quot;jquery.min.js&quot;, &quot;js/area.js&quot; ]&#125;, 而第一步設定好的那些內容，就是使用 chrome.storage.local.get，例如：123chrome.storage.local.get([&apos;ProgramSit&apos;, &apos;eventId&apos;], items =&gt; &#123; choosed_sit = `$&#123;items.eventId&#125;_$&#123;items.ProgramSit&#125;`;&#125;); chrome.storage.local.get 後面是接上陣列資料，陣列裡則是要取出來的 key 值。 4. 進入購票頁面後會自動帶好購買票數與勾選同意條款，並 focus 到驗證碼的 input最後一個流程使用到的就和 2,3 項目相同，都是透過 chrome api GET 設定好的參數，並取得網頁上的 DOM 元素寫入資料。到這一步將驗證碼填好後按下 enter 就送出了！ 實作小結雖然以上說明看起來是落落長，但實際上使用到的技巧到大同小異，了解了插件的結構以及具備前端的基礎技能（HTML, CSS, JavaScript）就能開發出屬於自己的工具了！ 因為目前我所開發過的類型都是偏向簡化網頁上的操作行為，所以在開發插件的時候，首先會先確定好這個插件所要完成的目標為何，並開始設計流程與觀察點擊後觸發的行為。最後再對應回去需要的架構與技巧～ 完整程式碼 為了達成簡化網頁上的操作行為，這邊一定要補充一個我常用的技巧！！ 補充：實用小技巧 - Postman Interceptor這是一個 Postman 的插件，在網頁上開啟它後，它可以取得在網頁的行為，因此當你想了解這個按鈕點下後是 GET 哪支 API 或是 POST 什麼資料出去、需要帶哪些參數，通通告訴你！！插件連結安裝好後，點一下接著就可以在 Postman 中的 history 看到這些行為 插件好處 因為是掛在網站下執行，所以 call api 時可以避免掉 cors 的問題 直接操作網站 DOM 元素，可以將操作介面流程自動化 extension 上架做完插件後，除了可以供給自己使用，也可以透過上架的方式，讓 extension 上到商店提供給其他人下載流程上也非常簡單，只要有 google 帳號，登入開發者頁面後，就可以選擇上傳檔案來上架。 上架需要 5 美金，付完之後就可以無限上架插件，只需要付費一次哦！上架之後也會由 google 進行審核，通過後就可以提供給大家安裝使用囉 流程的部分官方寫得蠻清楚的，附上連結提供參考 總結extension 的開發有蠻大一部分都與前端所需技能相符，因此有興趣的夥伴們也可以嘗試製作自己的插件看看，希望透過這篇文章帶大家認識 chrome extension，若是有開發出好玩的 extension 也歡迎大家跟我分享！ 參考資料https://developer.chrome.com/extensionshttps://ithelp.ithome.com.tw/users/20079450/ironman/1149https://github.com/dsync5566/tixCraftSupport","categories":[{"name":"Chrome","slug":"Chrome","permalink":"https://tzuhui.github.io/categories/Chrome/"}],"tags":[{"name":"chrome extension","slug":"chrome-extension","permalink":"https://tzuhui.github.io/tags/chrome-extension/"}]},{"title":"隨著六角飄到三週年同學會的葉子漂流記","slug":"Mine/hexschool-third-party","date":"2019-09-30T16:00:00.000Z","updated":"2019-10-09T09:40:26.869Z","comments":true,"path":"2019/10/01/Mine/hexschool-third-party/","link":"","permalink":"https://tzuhui.github.io/2019/10/01/Mine/hexschool-third-party/","excerpt":"這次同學會是我進六角以後第一次在實體見到學員，因為擔任助教的關係，有些學員的名字我都印象深刻，但都沒有見過本人，因此透過活動與大家見到面，有一種很特別的感覺！ 在同學會有一小段時間是讓學員們可以找大家聊天，當時有一些學員和我聊聊，我統整並分類了一下問題，並分享自己的想法。","text":"這次同學會是我進六角以後第一次在實體見到學員，因為擔任助教的關係，有些學員的名字我都印象深刻，但都沒有見過本人，因此透過活動與大家見到面，有一種很特別的感覺！ 在同學會有一小段時間是讓學員們可以找大家聊天，當時有一些學員和我聊聊，我統整並分類了一下問題，並分享自己的想法。 心理上的問題我很不好意思在社團上與大家交流怎麼辦？/我想找和我學習狀況相似的夥伴，但我很不擅於主動發文互動怎麼辦？當時我和她說，社團上的大家都很友善！沒關係，妳可以先試試看。說不定你的發文剛好也會吸引到和你相同的背景或是學習狀況的人。我也是比較不擅於在主動在線上交流的人，但最近也正嘗試在寫文作紀錄，妳也可以先嘗試看看，會有這樣的害怕是很正常的，妳不是一個人。 🍃葉子心裡話：當時被問這個問題時，我心裡有「咚」的一聲。因為這個問題好像同樣的發生在自己身上。我也是比較少在線上分享自身經驗的人，有蠻大一部分的原因是出自於我是一個比較沒有自信的人。曾經我也想過透過寫文的方式來分享，但通常都是寫了發不出去，就這樣成為永遠的草稿（莫名的糾結啊啊啊當時我有將這個情況和洧杰老師談談，其中有一個讓我印象深刻的話：「妳要先學會接納自己是什麼樣的人」如同前面提到，事實上我就是比較沒有自信的人，所以在寫文的時候會很糾結說這樣寫會不會讓人覺得怎麼樣怎麼樣之類的但學著面對這樣的自己，我告訴自己：「沒自信也沒關係的，就先試試看吧！總之我得先做，才有可能會發生我在憂慮的問題嘛！」於是慢慢開始試著去找一些小主題來寫，雖然不是博大精深，但總是踏出了那一小步！我知道這個努力讓我比前一刻的自己更勇敢了！ 學一學覺得有點怠惰了怎麼辦 / 全職轉職的壓力好大學習並不是只有在於時間長短，適當的休息與舒壓也是必須的！當壓力過大時很容易影響到專注度，而專注度也同樣會影響到學習的效率，或是因此產生情緒，讓自己對事情鑽牛角尖。因此我自己在壓力比較大的時候，會先給自己一些耍廢的時間。找一件可以讓自己放鬆的事情，例如：到書店看書 在書店時會多看一些最近煩惱的事情，並嘗試在書中找到一些方法來做嘗試。像是有一陣子我會有莫名的疲倦感，就買了『與焦慮和解』以及『五秒法則』等等的書，從書中了解的原來自己的狀況可能是因為焦慮，也從五秒法則這本書，試著了解自己每天的狀態。 🍃葉子心裡話：因此噴了不少在買書上呢… 有興趣或許可以來和我借（？） 看很多人分享都覺得他們好強，反觀自己會覺得好弱呀…通常你會覺得很強的對象，他們身上都有一個你想達到的目標。別急著反觀自己的弱項，可以試著思考看看，這個對象是哪一點讓你覺得厲害，或是是你想學習的。例如：某一項技術學得很深入、對底層觀念很熟悉、文章寫得很有條理、很會與他人互動等等，了解哪一部份是你認為很厲害的點之後，可以將這些事情記錄下來，並依照接下來想達成的或是有興趣的安排學習的先後順序。寫下來後一方面是可以減少焦慮，讓自己可以對下來要如何安排目標更有方向，另一方面也可以深入思考到這是否是你想繼續往前的方向。 剛入行前端一年多，接下來該怎麼走？其實六角學院是我第一份工作，而我進入到六角工作大約是一年多的時間，所以被問到這個問題時，其實我還蠻惶恐的，哈哈比起大多數經驗豐富的學長姐，我應該還算是個職場小菜鳥。因此只能就自己的想法給予一些建議，首推老師的文章：https://ithelp.ithome.com.tw/articles/10194994https://ithelp.ithome.com.tw/articles/10218115透過文章中可以了解到接下來自己可以去努力的方向。成為前端後我也會有很迷茫的時候，覺得技術不斷更新，而且看到徵才條件都要會好多，我是不是學更多種才可以呢？這個問題我自己的結論會傾向是先專精工作上所需要用到的技能，當工作也比較能穩定上手時，也比較會有多餘的時間或是精力去精進其他的技能。 學習上的問題跟著JS 課程寫作業都覺得很 ok，但自己要從零開始就沒辦法這個問題其實一直以來都有蠻多學員有這個疑問，因為跟著一步一步做，所以比較容易就忽略自己對這部分的掌握度，建議可以在完成後回頭看一次，有些學員也會在每一行加上註解，確定自己對於這個執行過程是了解的。接下來可以嘗試開發其他的專案，來鍛鍊自己對語法與邏輯的熟悉程度。初步要從零開始寫的時候通常都會毫無頭緒，此時會建議將想要做出來的功能寫下來，並切成一小個一小個功能，先專注在達成第一步，再繼續往後舉例來說：我想做出購物流程，那可能可以簡單分為以下幾步， 先有一個按鈕是可以『加入購物車』 加入購物車以後可以到購物車頁面，確認購買的商品 在此頁面可以刪除商品 填寫資料表單 送出 -&gt; 確認購買成功 因此第一步就先專注在新增點擊的監聽事件到按鈕上，並觸發將商品的資料加到購物車（可能是一個陣列）中，完成這一步後，再往第二部分來做 切成個別功能來做的好處在於，專心於某一個部分，且在完成一項後就會先得到成就感，再往下投入也會更有動力。但同樣也會有壞處，也就是這個方法容易想的不夠全面，因此比較建議是在初學熟悉的時候使用哩（請小心服用 如何準備作品集特別推薦大家可以到 THE F2E 前端修煉精神時光屋逛逛第一屆：https://www.facebook.com/groups/173311386703334/learning_content/第二屆：https://challenge.thef2e.com/兩屆的題目都不相同，而第二屆更是有許多 UI 設計師提供設計稿，可以到裡面找尋自己喜歡的版型來練習。這邊也有許多厲害的工程師的作品，有些甚至有提供原始碼可以參考，可說是人人有功練的好去處呢！ 這邊也提倡一下，在六角學習的好處就是，若你做完了課程最終作業，可以申請求職輔導的服務，也可以提供自己的履歷與作品集請老師幫忙看，現在也有人才牆的服務（這不是業配，是真心 R! 關於助教的問題一題問題都花多少時間回覆？回覆問題的時間會依照熟練程度以及問題難度而定。先以熟練度來說，我剛到六角的時候，大概是一個 HTML 課程就需要花 2-3 小時的時間回覆。後來比較熟練回覆以後，慢慢增加課程，到後面大概是 2-3 小時 4 個課程（網頁排版）至於 JS 或是 Vue 就會更無法拿捏時間，有時候可能一題就一小時了！這就是問題難度的部分～ 而遇到真的無法解的問題，就會詢問老師。目前因為有遠端助教的幫忙，就轉為檢視的角色，自己回覆的時間就少了許多。 每天打開問答區會不會覺得很厭世？看到問題量很多或是瀏覽過一次問題，發現似乎有比較難解的，會有一點小壓力但是解完問題，或是整理出一個詳細的回覆提供給學員參考時，就會有一種爽感 XD最重要的是，當看到學員點擊回覆有幫助或是回覆說謝謝，心裡都會偷偷竊喜一下。 🍃葉子心裡話：同學會當天有兩個可愛的女孩說要和我告白，感謝我的回覆當時真的是非常開心，了解到自己的回覆是真的有幫助到別人的時候，就會覺得很有成就感呢！ 問題都是你看過的嗎？其實每週都一定會有我不熟悉的問題，但也是因為接受到各種問題，讓我也從回覆中釐清很多觀念，這也是當助教的好處當看到不了解的問題，就是先 google 再說！透過 stackoverflow, mdn 以及官方文件或是網路上很多大神的文章都可以找到滿滿的資料，將資料搜集並整理後再回覆給學員，同時也是讓自己吸收與釐清的好方法哦 我想當遠端助教若你對遠端助教有興趣，非常歡迎加入！我們都會不定期徵選，條件與職務內容可以參考文章https://www.hexschool.com/2019/08/01/2019-08-01-remote-jobs-second/ 擔任遠端助教的好處是可以透過大量的問題，釐清自己的觀念，從中也可以獲得成就感因為是有給職，所以對於全職轉職的學員，也可以多一份收入減低生活壓力 最後，我想感謝…非常感謝那天來和我說謝謝以及來找我聊聊的學員們你們也給我很大的鼓勵！有你們才促成了這篇文章希望這篇文章也同樣可以給予你們力量，讓你們可以找到自己想邁進的方向！也很感謝和我說官網做得好的學長姊，被你們肯定讓我很感動啊啊啊～我也會繼續努力，與大家一起成長的！也謝謝六角，讓我的人生又添上一筆美好的回憶記錄 :D","categories":[{"name":"葉子漂流記","slug":"葉子漂流記","permalink":"https://tzuhui.github.io/categories/葉子漂流記/"}],"tags":[{"name":"六角","slug":"六角","permalink":"https://tzuhui.github.io/tags/六角/"}]},{"title":"Lottie 輕鬆實現動畫效果","slug":"JavaScript/lottie/lottie-intro","date":"2019-09-25T16:00:00.000Z","updated":"2019-09-26T17:43:12.807Z","comments":true,"path":"2019/09/26/JavaScript/lottie/lottie-intro/","link":"","permalink":"https://tzuhui.github.io/2019/09/26/JavaScript/lottie/lottie-intro/","excerpt":"Lottie 是 Airbnb 開源的跨平台動畫函式庫，設計師可以透過 Adobe After Effects 做出動畫後，經由一個 Bodymovin 的擴充功能輸出 JSON 格式。接著再由工程師透過 Lottie 函式庫讀取 JSON 資料來呈現出動畫。","text":"Lottie 是 Airbnb 開源的跨平台動畫函式庫，設計師可以透過 Adobe After Effects 做出動畫後，經由一個 Bodymovin 的擴充功能輸出 JSON 格式。接著再由工程師透過 Lottie 函式庫讀取 JSON 資料來呈現出動畫。 Lottie 官網：http://airbnb.io/lottie/#/這篇主要說明在 Web 使用 Lottie：https://github.com/airbnb/lottie-web 實作首先可以在 Lottie 官網的動畫分類找到很多設計師的作品，從中選擇一個來實作看看吧！ 載入 Lottie 資源 CDN1https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.5.9/lottie.min.js npm1npm install lottie-web 初始化 將下面程式碼加入，並加入對應的參數資料就可以啟用了123456lottie.loadAnimation(&#123; wrapper: svgContainer, animType: 'svg', loop: true, path: 'https://assets4.lottiefiles.com/packages/lf20_Sjy4Vl.json'&#125;); container: 對應的 HTML 元素 id animationData: 動畫的 JSON 資料 path: 動畫的 JSON 資料來源 (animationData、path 擇一使用即可) loop: 循環播放 (true / false / number) autoplay: 自動播放（true / false） name: 名稱 renderer: 設置渲染器（’svg’ / ‘canvas’ / ‘html’） 預設使用 svg 渲染 差異： svg：元素使用 svg 呈現，動畫效果透過 svg 的動畫來做 canvas：元素使用 canvas 繪製，透過定時刷新重繪呈現動畫效果 html：元素使用 svg 呈現，動畫效果透過 CSS 的動畫來做 除了基礎的參數以外，還有許多事件可以設置 (播放、暫停、播放速度等等)，使用方式舉例：1234567const anlottie = lottie.loadAnimation(&#123; container: svgContainer, animType: 'svg', loop: true, path: 'https://assets4.lottiefiles.com/packages/lf20_Sjy4Vl.json',&#125;);anlottie.setSpeed(6); 透過 setSpeed() 就可以加快動畫的速度。常用也包括 play()、stop()、pause(); 可設置參數詳細內容可參考這裡：https://airbnb.io/lottie/#/web?id=usage-1 Demo 使用 Lottie 好處1. 清晰在任何高分辨率顯示器上就能看出差異。點我觀看 2. 輕巧同樣使用呈現動畫的 gif 圖片來說，一個 JSON 檔案會小許多。 3. 方便方便的呈現複雜動畫效果，不用寫很多 code 來處理，只要提供對應的 JSON 動畫資源即可。 小結要在網頁上呈現複雜動畫時，可以試著用 Lottie 來完成哦！","categories":[{"name":"JS","slug":"JS","permalink":"https://tzuhui.github.io/categories/JS/"}],"tags":[{"name":"技術筆記","slug":"技術筆記","permalink":"https://tzuhui.github.io/tags/技術筆記/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tzuhui.github.io/tags/JavaScript/"},{"name":"lottie","slug":"lottie","permalink":"https://tzuhui.github.io/tags/lottie/"}]},{"title":"gulp 3 遷移至 gulp 4","slug":"JavaScript/gulp/gulp3-to-4","date":"2019-08-28T16:00:00.000Z","updated":"2019-09-07T04:08:35.532Z","comments":true,"path":"2019/08/29/JavaScript/gulp/gulp3-to-4/","link":"","permalink":"https://tzuhui.github.io/2019/08/29/JavaScript/gulp/gulp3-to-4/","excerpt":"從 2018 年 10 月開始，使用 npm 下載 gulp 預設的版本都將為 4，因 gulp 3 與 4 在寫法上有些更新，所以在安裝 4 的情況之下，運行 3 的寫法是有可能會出錯的，因此這篇主要說明 gulp 3 與 4 的差異","text":"從 2018 年 10 月開始，使用 npm 下載 gulp 預設的版本都將為 4，因 gulp 3 與 4 在寫法上有些更新，所以在安裝 4 的情況之下，運行 3 的寫法是有可能會出錯的，因此這篇主要說明 gulp 3 與 4 的差異 若仍需要使用 gulp 3，也可以用此指令安裝 3 的版本1npm install gulp@^3.9.1 使用 series() 取代原本 Arrays 任務安排的寫法Gulp 4 介紹了新的組合任務方法：series()、parallel() series() 按指定的順序一次運行一個任務parallel() 以任何順序同時運行任務 舉例：在 gulp 31gulp.task(&apos;default&apos;, [&apos;browserSync&apos;]); 轉換到 gulp 41gulp.task(&apos;default&apos;, gulp.series(&apos;browserSync&apos;)) 兩者也可以混用，例如：1gulp.task(&apos;build&apos;, gulp.series(&apos;clean&apos;, gulp.parallel(&apos;sass&apos;, &apos;vendorJs&apos;))); 這樣的寫法也是先執行 clean 後再執行後面的 sass, vendorJS而 sass, vendorJS 是同時執行的 使用 done() - 當任務結束後的 callback12345678gulp.task(&apos;default&apos;, gulp.series(&apos;clean&apos;, gulp.parallel(&apos;sass&apos;, &apos;vendorJs&apos;), function(done) &#123; // 也就是先確保前面都執行完 gulp.watch([&apos;./source/stylesheets/**/*.sass&apos;, &apos;./source/stylesheets/**/*.scss&apos;],gulp.series(&apos;sass&apos;)); done(); &#125;)); 模組化設計 - 將 task 改用一般的函式寫法好處在於可以更方便的管理使用。 另外建立一個 JS 檔 (ex: vendor.js )，並將 task 改用函式的方式來寫 舉例：12345678gulp.task(&apos;vendorJs&apos;, function () &#123; return gulp.src([ &apos;./node_modules/jquery/dist/jquery.slim.min.js&apos;, &apos;./node_modules/bootstrap/dist/js/bootstrap.bundle.min.js&apos; ]) .pipe($.concat(&apos;vendor.js&apos;)) .pipe(gulp.dest(&apos;./public/javascripts&apos;))&#125;) 改用函式的寫法：12345678910const vendorJs = function(done) &#123; gulp.src([ &apos;./node_modules/jquery/dist/jquery.slim.min.js&apos;, &apos;./node_modules/bootstrap/dist/js/bootstrap.bundle.min.js&apos; ]) .pipe($.concat(&apos;vendor.js&apos;)) .pipe(gulp.dest(&apos;./public/javascripts&apos;)) done();&#125;;exports.vendorJs = vendorJs; 在原本的 JS 檔（主要安排與執行任務的檔案，ex: index.js）將上面寫好的檔案引入 1const &#123; vendorJs &#125; = require(&apos;./vendor.js&apos;); 最後將 vendorJs 安排到任務執行 1gulp.series(vendorJs) 要注意因為是引入的方法，所以這邊安排任務不是使用字串 &#39;&#39; 寫法","categories":[{"name":"gulp","slug":"gulp","permalink":"https://tzuhui.github.io/categories/gulp/"}],"tags":[{"name":"技術筆記","slug":"技術筆記","permalink":"https://tzuhui.github.io/tags/技術筆記/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tzuhui.github.io/tags/JavaScript/"},{"name":"gulp","slug":"gulp","permalink":"https://tzuhui.github.io/tags/gulp/"}]},{"title":"在專案引入 gulp 4.0 並開啟 Ｗeb Server (使用 browser-sync)","slug":"JavaScript/gulp/gulp-browserSync","date":"2019-08-16T16:00:00.000Z","updated":"2019-08-17T05:11:36.563Z","comments":true,"path":"2019/08/17/JavaScript/gulp/gulp-browserSync/","link":"","permalink":"https://tzuhui.github.io/2019/08/17/JavaScript/gulp/gulp-browserSync/","excerpt":"這篇是使用 gulp 4，所以使用 gulp 3 要注意 task 安排的寫法正文開始！這一篇要從資料夾中只含有一個 index.html 檔案開始說起","text":"這篇是使用 gulp 4，所以使用 gulp 3 要注意 task 安排的寫法正文開始！這一篇要從資料夾中只含有一個 index.html 檔案開始說起 1. 初始化套件管理器 ( NPM )1npm init 下指令後會有一些需要輸入的內容，懶人建立就都按 Enter 就好完成後資料夾中就會有 package.json 檔案了 2. 新增一個 JS 檔案ex: gulpfile.js用來加入 gulp 任務 3. require gulp 模組在終端機下指令1npm install gulp 在 gulpfile.js 寫入1const gulp = require(&apos;gulp&apos;); 引入 gulp 後可以使用 gulp.task 來執行任務例如：1gulp.task(&apos;default&apos;, gulp.series(&apos;browserSync&apos;)) 在 gulp4 中可使用 gulp.series() 和 gulp.parallel() 來安排任務進行 gulp.series() -&gt; 按照順序進行gulp.parallel() -&gt; 同時進行&#39;default&#39; -&gt; 任務名稱&#39;browserSync&#39; -&gt; 任務的內容 了解任務要如何安排後，接下來要安裝用來開始 web server 的套件 - browser-sync 4. 載入 browser-sync 套件在終端機下指令安裝 browser-sync1npm install browser-sync 在 gulpfile.js 寫入1const browserSync = require(&apos;browser-sync&apos;); 5. 使用 browserSync 所提供的方法來 init參考寫法：1234567gulp.task(&apos;browserSync&apos;, function () &#123; browserSync.init(&#123; server: &#123; baseDir: &apos;./&apos;, // 指向要開啟的資料夾 &#125;, &#125;)&#125;); 6. 執行 gulp 就可以順利開啟 web server 啦小補充 - 運用 gulp watch() 讓檔案有更動時自動 reloadgulp watch 是用於監看全局任務，因此可以用於當檔案發生改變時觸發某行為例如：1gulp.watch(&quot;*.html&quot;).on(&quot;change&quot;, browserSync.reload); 也就是當 HTML 檔案有更動時，在儲存的同時 web server 也會 reload，這樣在開發上就更方便啦～ 更多 browser-sync 使用方法請見：https://browsersync.io/docs/gulp#gulp-install","categories":[{"name":"gulp","slug":"gulp","permalink":"https://tzuhui.github.io/categories/gulp/"}],"tags":[{"name":"技術筆記","slug":"技術筆記","permalink":"https://tzuhui.github.io/tags/技術筆記/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tzuhui.github.io/tags/JavaScript/"},{"name":"gulp","slug":"gulp","permalink":"https://tzuhui.github.io/tags/gulp/"}]},{"title":"在 Vue Cli 中加入自定義 Bootstrap 樣式","slug":"Bootstrap/vue-cli-use-bootstrap","date":"2019-06-19T16:00:00.000Z","updated":"2019-06-20T17:03:59.364Z","comments":true,"path":"2019/06/20/Bootstrap/vue-cli-use-bootstrap/","link":"","permalink":"https://tzuhui.github.io/2019/06/20/Bootstrap/vue-cli-use-bootstrap/","excerpt":"常常忘記該怎麼加入自定義的 Bootstrap 樣式，所以直接記下來不囉唆！基礎的引入很簡單，按照步驟一定搞定～","text":"常常忘記該怎麼加入自定義的 Bootstrap 樣式，所以直接記下來不囉唆！基礎的引入很簡單，按照步驟一定搞定～ 安裝 1npm install bootstrap --save 在 src 下的 assets 建立 helpers 資料夾並將 node_moduled 中的 bootstrap _variables.scss 複製過去 在 src 下的 assets 建立 all.scss 檔案用來管理所有 scss 在 all.scss 引入順序 123@import \"~bootstrap/scss/functions\";@import 'helpers/variables';@import \"~bootstrap/scss/bootstrap\"; 在 App.vue 中引入 all.scss 123&lt;style lang=\"scss\"&gt; @import \"./assets/all.scss\"&lt;/style&gt; 如果要再加入其他自定義的 scss 可以在 src 下的 assets 建立 components 資料夾ㄅㄨ並加入自定義的元件 scss 樣式，接著再 all.scss 引入就完成了！","categories":[{"name":"Bootstrap 筆記","slug":"Bootstrap-筆記","permalink":"https://tzuhui.github.io/categories/Bootstrap-筆記/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://tzuhui.github.io/tags/Vue/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://tzuhui.github.io/tags/Bootstrap/"},{"name":"技術筆記","slug":"技術筆記","permalink":"https://tzuhui.github.io/tags/技術筆記/"}]},{"title":"連葉子都秒懂的 Fast Forward","slug":"Git/fast-forward","date":"2019-06-19T16:00:00.000Z","updated":"2019-06-20T17:03:42.005Z","comments":true,"path":"2019/06/20/Git/fast-forward/","link":"","permalink":"https://tzuhui.github.io/2019/06/20/Git/fast-forward/","excerpt":"fast-forward 出現時機在進行 merge 的時候，git 預設會以 fast-forward 的模式進行","text":"fast-forward 出現時機在進行 merge 的時候，git 預設會以 fast-forward 的模式進行 情境說明：當開設 branch feature/add-page 後要回到 master 合併 branch目前狀況： 若使用預設的 merge 採用 fast-forward 進行： 會將 branch 的 commit 紀錄合併到 master 上 指令：git merge feature/add-page 不使用 fast-forward ，以 no fast-forward 進行： 會保留原始 branch 上的 commit 紀錄，並在 master 上增加一個merge branch &#39;feature/add-page&#39; into master 指令：git merge feature/add-page --no-ff–no-ff 不要快速合併 no fast-forward 的好處 可以完整保留每一個分支的 commit 紀錄 no fast-forward 的壞處 若是 commit 紀錄只有一個，合併多次就會出現很多小叉路","categories":[{"name":"Git 筆記","slug":"Git-筆記","permalink":"https://tzuhui.github.io/categories/Git-筆記/"}],"tags":[{"name":"技術筆記","slug":"技術筆記","permalink":"https://tzuhui.github.io/tags/技術筆記/"},{"name":"git","slug":"git","permalink":"https://tzuhui.github.io/tags/git/"}]},{"title":"Vue CLI 3 環境變數設置","slug":"Vue/Vue-CLI3-env","date":"2019-01-07T16:00:00.000Z","updated":"2019-06-20T17:03:40.688Z","comments":true,"path":"2019/01/08/Vue/Vue-CLI3-env/","link":"","permalink":"https://tzuhui.github.io/2019/01/08/Vue/Vue-CLI3-env/","excerpt":"使用 Vue 開發時若有使用到 firebse 資料庫，會需要將資料庫金鑰加入到專案中，但在 commit 時不建議將金鑰也一併 commit 到公開的儲存庫上，這時就會建議使用環境變數","text":"使用 Vue 開發時若有使用到 firebse 資料庫，會需要將資料庫金鑰加入到專案中，但在 commit 時不建議將金鑰也一併 commit 到公開的儲存庫上，這時就會建議使用環境變數 新增一個 .env.local新增的 .env.local 會在所有環境中被載入，但會被 git 忽略在 .env.local 中加入環境變數，例如：123456FIREBASE_APIKEY=KeyFIREBASE_AUTODOMAIN=DomainFIREBASE_DATABASEURL=DatabaseUrlFIREBASE_PROJECTID=ProjectIdFIREBASE_STORAGEBUCKET=StorageBucketFIREBASE_MESSAGINGSENDERID=MessagingsId 左邊為環境變數的變數名稱，通常以全部都大寫字母來命名右邊是金鑰的內容，在 firebase 中可以取得相關的資料 在 JS 中取得環境變數設置在 JS 中要使用環境變數，只要在變數前加上 process.env 就可以了～例如：1process.env.FIREBASE_APIKEY 部署要注意的地方將金鑰改為環境變數之後，因為只有在本地端才能使用，所以要注意部署網站時要將環境變數設定到機器上以部署到 heroku 為例： 進入 heroku 專案畫面，點選 Settings，在 Settings 頁面有設定環境變數的地方 - Config Vars 點選 Reveal Config Vars 將變數加上，如下圖： 官網的環境變數說明：https://cli.vuejs.org/zh/guide/mode-and-env.html","categories":[{"name":"Vue 筆記","slug":"Vue-筆記","permalink":"https://tzuhui.github.io/categories/Vue-筆記/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://tzuhui.github.io/tags/Vue/"},{"name":"技術筆記","slug":"技術筆記","permalink":"https://tzuhui.github.io/tags/技術筆記/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tzuhui.github.io/tags/JavaScript/"}]},{"title":"Vue CLI 3 快速建立篇","slug":"Vue/Vue-CLI3-create","date":"2018-12-27T16:00:00.000Z","updated":"2019-06-20T17:03:40.688Z","comments":true,"path":"2018/12/28/Vue/Vue-CLI3-create/","link":"","permalink":"https://tzuhui.github.io/2018/12/28/Vue/Vue-CLI3-create/","excerpt":"Vue CLI 3 在建立專案上已經可以利用 GUI 的方式來建立，不需要輸入一堆指令！官網說明：https://cli.vuejs.org/zh/guide/creating-a-project.html","text":"Vue CLI 3 在建立專案上已經可以利用 GUI 的方式來建立，不需要輸入一堆指令！官網說明：https://cli.vuejs.org/zh/guide/creating-a-project.html 使用 GUI 介面建立專案先介紹如何使用 GUI 介面建立專案 在終端機輸入：1vue ui 輸入後就會開啟一個瀏覽器介面，如下圖： 建立新專案點選創建，並選擇要創建專案的資料夾位置，選好後按下在此建立項目即可 Step1: 詳情 (Details)預設是填寫專案名稱以及選擇模組管理要使用 npm 或是 yarn，選擇預設則會兩者都有安裝，最後也有提供創建 git 的選擇可以依照自己的開發習慣填入，就可以到下一步了～ Step2: 預設 (Presets)預設有提供三個選項: 默認 (Default preset) 手動 (Manual) 遠程預設 (Remote preset) 默認 (Default preset)默認是一套已經定義好的插件與配置，選擇後就會使用這個配置直接創建專案預設也可以自己設定，可以透過選擇手動 (Manual) 來選取自己在開發上常用的配置並設為預設 手動 (Manual)只有選擇手動才會進入頁面中的功能與配置頁面 選擇手動 (Manual) 配置可以選擇下一步，就會進入功能頁面（Step3） 可以選擇自己常用的插件，像是 Bebal、ESLint、CSS 預處理器等等 選擇好以後按下一步就會進入到最後的配置頁面（Step4）這邊可以選擇像是 ESLint 要使用何種規範等等的細節設定 遠程預設 (Remote preset)遠程預設是可以使用 github、gitlab 等等已經設定好的遠端設定檔來直接創建專案主要是載入 preset.json 這個檔案 如果是使用 github 公開儲存庫中的檔案只要輸入 username / repo 就可以了如果是使用 gitlab, bitbucket 可以在前面加上前綴詞 這邊載入的是這位作者寫好的：https://github.com/xiabaiyang/vue-preset 以上，不管使用何種方式都可以建立起一個新專案～ RUN 一下新建立的專案在終端機輸入：npm1npm run serve yarn1yarn serve 就可以建立起來了！畫面： 還想再安裝插件如果在預設的時候沒有選擇好插件或是配置，可以再透過指令在建置好的專案中加入 例如： ESLint在終端機輸入：1vue add @vue/eslint 加入 Router1vue add router","categories":[{"name":"Vue 筆記","slug":"Vue-筆記","permalink":"https://tzuhui.github.io/categories/Vue-筆記/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://tzuhui.github.io/tags/Vue/"},{"name":"技術筆記","slug":"技術筆記","permalink":"https://tzuhui.github.io/tags/技術筆記/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tzuhui.github.io/tags/JavaScript/"}]},{"title":"Vue CLI 3 安裝篇","slug":"Vue/Vue-CLI3-install","date":"2018-12-27T16:00:00.000Z","updated":"2019-06-20T17:03:40.688Z","comments":true,"path":"2018/12/28/Vue/Vue-CLI3-install/","link":"","permalink":"https://tzuhui.github.io/2018/12/28/Vue/Vue-CLI3-install/","excerpt":"Vue CLI 3 安裝非常簡單和官網上說明的可以說是一模一樣 XD官網說明：https://cli.vuejs.org/zh/guide/","text":"Vue CLI 3 安裝非常簡單和官網上說明的可以說是一模一樣 XD官網說明：https://cli.vuejs.org/zh/guide/ Stpe1: 卸載舊版 Vue CLI(本來就沒有安裝 Vue CLI 的話就可以跳過此步驟)Vue CLI 的模組名稱已經由 vue-cli 改成了 @vue/cli所以如果已經全局安裝 vue-cli (1.x 或 2.x)，要先卸載 在終端機輸入： npm1npm uninstall vue-cli -g yarn1yarn global remove vue-cli Stpe2: 安裝 CLI 3 指令卸載後就可以安裝 CLI 3 在終端機輸入： npm1npm install -g @vue/cli yarn1yarn global add @vue/cli Stpe3: 確認 Vue CLI 版本1vue --version 如果顯示 3.x.x 就代表安裝成功 安裝完成後就可以來建立專案囉！ 裝了 CLI 3 還是可以用 CLI 2 的模板Vue CLI 3 和以往的版本都使用了相同的 vue 命令所以如果要使用舊版的 vue init，只要全局安裝一個工具 在終端機輸入： 1npm install -g @vue/cli-init 安裝完後 ·vue init，vue init 的執行結果會和 vue-cli@2.x 相同1vue init webpack my-project","categories":[{"name":"Vue 筆記","slug":"Vue-筆記","permalink":"https://tzuhui.github.io/categories/Vue-筆記/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://tzuhui.github.io/tags/Vue/"},{"name":"技術筆記","slug":"技術筆記","permalink":"https://tzuhui.github.io/tags/技術筆記/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tzuhui.github.io/tags/JavaScript/"}]}]}